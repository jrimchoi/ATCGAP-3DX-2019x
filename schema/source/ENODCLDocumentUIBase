
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import matrix.db.AccessConstants;
import matrix.db.Context;
import matrix.db.JPO;
import matrix.db.RelationshipType;
import matrix.db.State;
import matrix.db.StateList;
import matrix.db.User;
import matrix.util.MatrixException;
import matrix.util.StringList;
import com.dassault_systemes.enovia.documentcommon.DCUtil;
import matrix.db.BusinessObject;

import com.dassault_systemes.enovia.controlledprinting.ControlledPrintingUtil;
import com.dassault_systemes.enovia.controlledprinting.service.ControlledPrintingService;
import com.dassault_systemes.enovia.controlledprinting.service.impl.ControlledPrintingServiceImpl;
import com.dassault_systemes.enovia.dcl.DCLConstants;
import com.dassault_systemes.enovia.dcl.DCLException;
import com.dassault_systemes.enovia.dcl.DCLServiceUtil;
import com.dassault_systemes.enovia.dcl.DCLUtil;
import com.dassault_systemes.enovia.dcl.TableRowId;
import com.dassault_systemes.enovia.dcl.service.ControlledDocumentService;
import com.dassault_systemes.enovia.dcl.service.DCLLifecycleService;
import com.dassault_systemes.enovia.dcl.service.HistoryAuditTrailService;
import com.dassault_systemes.enovia.dcl.service.impl.TrainingServiceImpl;
import com.dassault_systemes.enovia.documentcommon.DCConstants;
import com.dassault_systemes.enovia.documentcommon.DCDocument;
import com.dassault_systemes.enovia.documentcommon.DCUtil;
import com.dassault_systemes.enovia.enterprisechangemgt.common.ChangeAction;
import com.dassault_systemes.enovia.enterprisechangemgt.common.ChangeConstants;
import com.dassault_systemes.enovia.enterprisechangemgt.common.ChangeManagement;
import com.dassault_systemes.enovia.enterprisechangemgt.common.ChangeOrder;
import com.dassault_systemes.enovia.enterprisechangemgt.common.ChangeOrderUI;
import com.dassault_systemes.enovia.enterprisechangemgt.common.ChangeRequest;
import com.dassault_systemes.enovia.periodicreview.PeriodicReviewConstants;
import com.dassault_systemes.enovia.periodicreview.PeriodicReviewServiceUtil;
import com.dassault_systemes.enovia.periodicreview.service.PeriodicReviewService;
import com.matrixone.apps.common.CommonDocument;
import com.matrixone.apps.common.Person;
import com.matrixone.apps.domain.DomainConstants;
import com.matrixone.apps.domain.DomainObject;
import com.matrixone.apps.domain.DomainRelationship;
import com.matrixone.apps.domain.DomainSymbolicConstants;
import com.matrixone.apps.domain.util.ContextUtil;
import com.matrixone.apps.domain.util.EnoviaResourceBundle;
import com.matrixone.apps.domain.util.FrameworkException;
import com.matrixone.apps.domain.util.FrameworkUtil;
import com.matrixone.apps.domain.util.MapList;
import com.matrixone.apps.domain.util.MessageUtil;
import com.matrixone.apps.domain.util.MqlUtil;
import com.matrixone.apps.domain.util.PersonUtil;
import com.matrixone.apps.domain.util.PolicyUtil;
import com.matrixone.apps.domain.util.PropertyUtil;
import com.matrixone.apps.domain.util.XSSUtil;
import com.matrixone.apps.domain.util.i18nNow;
import com.matrixone.apps.framework.ui.UICache;
import com.matrixone.apps.framework.ui.UIComponent;
import com.matrixone.apps.framework.ui.UIUtil;

public class ${CLASSNAME} {

	/**
	 * Access program for policy field on create Document/Document Template page
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments.
	 * @return boolean status to show "Policy" Field.
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public boolean showPolicyField(Context context,String[] args) throws DCLException {
		boolean isDisplay = false;
		try {
			List<String> slPolicies = new StringList();
			Map<?,?> hmParamMap = (Map<?,?>) JPO.unpackArgs(args); 
			String strDCmode = (String) hmParamMap.get(DCConstants.DCMODE);
			String strType = (String) hmParamMap.get(DomainConstants.SELECT_TYPE);
			String strSelType = DCLUtil.getTypeAfterSplit(context,strType);
			if(DCLConstants.CREATEDOCUMENT.equals((strDCmode))) {
				ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
				slPolicies = documentService.getGovernedPolicies(context,strSelType,false);
				if(!slPolicies.isEmpty() && slPolicies.size()>1) {
					isDisplay = true;
				}
			} 
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		} 
		return isDisplay;
	}

	/**
	 * Method to get the list of policies
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments.
	 * @return Map of all policies of governed by selected type
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public Map getPolicies(Context context,String[] args) throws DCLException {
		Map<String, StringList> hmReturn = new HashMap<String, StringList>();
		try {
			StringList slPolicy = new StringList();
			Map hmParamMap = (Map) JPO.unpackArgs(args);
			Map requestMap = (Map) hmParamMap.get(DCLConstants.REQUESTMAP);
			String strType = (String) requestMap.get(DomainConstants.SELECT_TYPE);
			String strDCmode = (String) requestMap.get(DCConstants.DCMODE);
			String strSelType = DCLUtil.getTypeAfterSplit(context, strType);

			if(DCLConstants.CREATEDOCUMENT.equals((strDCmode))) {
				ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
				slPolicy = documentService.getGovernedPolicies(context,strSelType,false);
				hmReturn.put(DCLConstants.FIELD_CHOICES, slPolicy);
				hmReturn.put(DCLConstants.FIELD_DISPLAY_CHOICES, slPolicy);
			}
		}catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		return hmReturn;
	}

	/**
	 * Post process JPO method to post process for Document
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments.
	 * @return Map containing script to be executed
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String, String> createDocumentPostProcess(Context context, String[] args) throws DCLException {
		try {
			final String STR_TYPE_CONTROLLEDDOCUMENTS = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CONTROLLED_DOCUMENTS);
			String attribute_PeriodicReviewInterval=PropertyUtil.getSchemaProperty(context,"attribute_PeriodicReviewInterval");
			String attribute_PeriodicReviewEnabled=PropertyUtil.getSchemaProperty(context,"attribute_PeriodicReviewEnabled");
			String relSME=PropertyUtil.getSchemaProperty(context,"relationship_SubjectMatterExpert");

			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			PeriodicReviewService periodicReviewService = PeriodicReviewServiceUtil.getPeriodicReviewService(context);
			Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
			String[] saObjectId = (String[]) programMap.get(DCLConstants.NEW_OBJECTID);
			String[] saRespOrg = (String[]) programMap.get(DCLConstants.ResponsibleOrganization);
			String[] saSubMatterExpId = (String[]) programMap.get(DCLConstants.SubjectMatterExpertOID);
			String[] saPeriodicReviewEnabled = (String[]) programMap.get(DCLConstants.PeriodicReviewEnabled);
			String[] saPeriodicReviewInterval = (String[]) programMap.get(DCLConstants.PeriodicReviewInterval);
			String[] strTemplateOID = (String[]) programMap.get(DCLConstants.TEMPLATE_OID);
			String[] strTitle = (String[]) programMap.get("Title");
			String[] strDesc = (String[]) programMap.get("Description");
			String strTrainingEnabledAttribute = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_TRAINING_ENABLED);
			String[] strTrainingEnabledAttributeValue = (String[]) programMap.get(strTrainingEnabledAttribute.replace(" ", ""));
			if (null == strDesc)
				strDesc = (String[]) programMap.get("DescriptionDisplay");		
			if (null == strTemplateOID)
				strTemplateOID = (String[]) programMap.get(DCLConstants.selTemplateId);

			String[] saActionMode = (String[]) programMap.get(DCConstants.ACTION_MODE);
			String[] saFileCheckin = (String[]) programMap.get(DCLConstants.FileCheckin);
			String[] saDocCategory=(String[]) programMap.get(DCLConstants.CATEGORY);

			String strAttrValue=DomainConstants.EMPTY_STRING;
			DomainObject dobjNew =DomainObject.newInstance(context,saObjectId[0]);

			Map<String, String> mpReturn = new HashMap<String, String>();
			StringList slSelect = new StringList(3);
			slSelect.add(DomainConstants.SELECT_TYPE);
			slSelect.add(DomainConstants.SELECT_NAME);
			slSelect.add(DomainConstants.SELECT_REVISION);

			//To add interface DCLEffectivity on QSD.
			DCLUtil.mqlCommand(context, "modify bus $1 add interface $2", true, saObjectId[0],DCLConstants.Interface_DCLEffectivity);


			//To set category Interface on Object if it doesn't exist & set the attribute value
			String 	strDocTempType=dobjNew.getInfo(context, DomainConstants.SELECT_TYPE);
			String strCommand = "print type $1 select $2 dump";
			String result = MqlUtil.mqlCommand(context, strCommand, false, strDocTempType, "kindof["+STR_TYPE_CONTROLLEDDOCUMENTS+"]");
			String strInterfaceOnDocument=DCLUtil.mqlCommand(context, "print bus $1 select interface dump $2", false, saObjectId[0],"\\|");

			if(result.equalsIgnoreCase(DCLConstants.TRUE)){
				if(DCLUtil.isNullOrEmpty(strTemplateOID[0])){
					String strInterface=DCLUtil.getInterfaceForTypeDocumentCategory(context, strDocTempType);
					if(!DCLUtil.isNullOrEmpty(strInterface)){
						//add interface on bus only if not already added
						if(!strInterfaceOnDocument.contains(strInterface)){
							DCLUtil.mqlCommand(context, "modify bus $1 add interface $2", true, saObjectId[0],strInterface);
						}
						String strAttribute=DCLUtil.mqlCommand(context, "list attribute $1 where $2", false, "*","owner==\""+strInterface+"\"");
						if( strAttribute.contains(DCLConstants.DOCUMENT_CATEGORY)){
							strAttrValue=saDocCategory[0];
							dobjNew.setAttributeValue(context,strAttribute, strAttrValue);
						}
					}
				}else{
					String strInterface=DCLUtil.getInterfaceAppliedOnTemplateForDocumentCategory(context, strTemplateOID[0]);
					DomainObject dObjTemp=DomainObject.newInstance(context, strTemplateOID[0]);
					if(!DCLUtil.isNullOrEmpty(strInterface)){
						//add interface on bus only if not already added
						if(!strInterfaceOnDocument.contains(strInterface)){
							DCLUtil.mqlCommand(context, "modify bus $1 add interface $2", true, saObjectId[0],strInterface);
						}
						String strAttribute=DCLUtil.mqlCommand(context, "list attribute $1 where $2", false, "*","owner==\""+strInterface+"\"");
						if( strAttribute.contains(DCLConstants.DOCUMENT_CATEGORY)){
							strAttrValue=dObjTemp.getAttributeValue(context, strAttribute);
							dobjNew.setAttributeValue(context,strAttribute, strAttrValue);
						}
					}
				}
			}

			if(null!=strTrainingEnabledAttributeValue)
				dobjNew.setAttributeValue(context,strTrainingEnabledAttribute, strTrainingEnabledAttributeValue[0]);

			Map<String, String> map = DCLUtil.getInfo(context, saObjectId[0], slSelect);
			boolean bUnique = documentService.checkTypeNameRevisionUnique(context, saObjectId[0]);
			if (bUnique) {
				boolean bRefreshTableContent = false;

				boolean boolDocTemplate=false;

				if(null != strTemplateOID && UIUtil.isNotNullAndNotEmpty(strTemplateOID[0]))
					boolDocTemplate=true;

				if(null == strTrainingEnabledAttributeValue && boolDocTemplate)
				{
					DomainObject domTemplate=new DomainObject(strTemplateOID[0]);
					String attributeValue=domTemplate.getAttributeValue(context, strTrainingEnabledAttribute);
					dobjNew.setAttributeValue(context, strTrainingEnabledAttribute, attributeValue);
				}
				else
					dobjNew.setAttributeValue(context,strTrainingEnabledAttribute, strTrainingEnabledAttributeValue[0]);

				if((null != saPeriodicReviewEnabled && !UIUtil.isNullOrEmpty(saPeriodicReviewEnabled[0]) || 
						boolDocTemplate))
				{
					String strPeriodicReviewEnabled="";
					String strPeriodicReviewIntervals="";
					String strSME="";

					if ((null != saPeriodicReviewEnabled && !UIUtil.isNullOrEmpty(saPeriodicReviewEnabled[0])))
					{
						strPeriodicReviewEnabled=saPeriodicReviewEnabled[0];
						if(saPeriodicReviewEnabled[0].equals(DCLConstants.YES))
						{
							strPeriodicReviewIntervals=saPeriodicReviewInterval[0];
							strSME=saSubMatterExpId[0];
						}
					}
					else if(boolDocTemplate)
					{
						DomainObject domTemplate=new DomainObject(strTemplateOID[0]);
						strPeriodicReviewEnabled=domTemplate.getAttributeValue(context, attribute_PeriodicReviewEnabled);
						strPeriodicReviewIntervals=domTemplate.getAttributeValue(context, attribute_PeriodicReviewInterval);
						String smeMemberListId=periodicReviewService.getSMEIfMemberList(context, strTemplateOID[0]);

						if(saSubMatterExpId!=null && UIUtil.isNotNullAndNotEmpty(saSubMatterExpId[0]))
							strSME=saSubMatterExpId[0];
						else if(UIUtil.isNotNullAndNotEmpty(smeMemberListId))
							strSME=smeMemberListId;
						else
							strSME=domTemplate.getInfo(context, "from["+relSME+"].to.id");
					}

					switch (strPeriodicReviewEnabled) {
					case DCLConstants.YES:
						periodicReviewService.enablePeriodicReview(context, new StringList(saObjectId[0]), strPeriodicReviewIntervals,
								strSME);
						break;
					case DCLConstants.NO:
						periodicReviewService.disablePeriodicReview(context, new StringList(saObjectId[0]));
						break;
					}
				}
				if (null != saRespOrg && !UIUtil.isNullOrEmpty(saRespOrg[0])) {
					documentService.updateResponsibleOrganization(context, saObjectId[0], saRespOrg[0]);
				}

				if ((null != saActionMode) && DCLConstants.REFERENCE_DOCUMENT.replaceAll(" ", DomainConstants.EMPTY_STRING).equals(saActionMode[0])) {
					String[] strparentOID = (String[]) programMap.get(DCConstants.PARENT_OID);
					DCDocument.addReferenceDocuments(context, strparentOID[0], saObjectId);
				}
				if (UIUtil.isNotNullAndNotEmpty(strTemplateOID[0])) {
					DomainObject dobjTemp = DomainObject.newInstance(context, strTemplateOID[0]);
					DCLUtil.checkInFile(context, dobjTemp, dobjNew);

					documentService.connectTemplateToDocument(context, strTemplateOID[0], saObjectId[0]);

					documentService.replicateSubscriptions(context, strTemplateOID[0], saObjectId[0], true, false);
					TrainingServiceImpl impl = new TrainingServiceImpl();
					impl.copyTrainees(context, strTemplateOID[0], dobjNew);
				}
				if(null != strDesc && UIUtil.isNotNullAndNotEmpty(strDesc[0])){
					dobjNew.setDescription(context, strDesc[0]);
				}
				if (saFileCheckin != null && DCLConstants.YES.equalsIgnoreCase(saFileCheckin[0])) {
					String strType = EnoviaResourceBundle.getProperty(context, "emxFrameworkStringResource", context.getLocale(),
							"emxFramework.Type." + map.get(DomainConstants.SELECT_TYPE).replace(" ", "_"));
					String strMessage = MessageUtil.getMessage(context, null, "enoDocumentCommon.Alert.Msg.SuccessfullCreate", new String[] {
							strType, map.get(DomainConstants.SELECT_NAME), map.get(DomainConstants.SELECT_REVISION) }, null, context.getLocale(),
							DCConstants.DC_STRING_RESOURCE);

					String categories=documentService.getCategories(context, saObjectId[0]);
					String showFileCategory;
					try {
						showFileCategory = EnoviaResourceBundle.getProperty(context, "enoDocumentControl.Files.EnableFileCategories");
					} catch (Exception e) {
						showFileCategory="false";
						categories="";
					}
					mpReturn.put(DCLConstants.ACTION_JAVASCRIPT, DCLUtil.encodeFunctionForJavaScript(context, false, "checkInFile",""+strMessage+"", saObjectId[0], String.valueOf(bRefreshTableContent),showFileCategory,categories));	//quotes have been used with strMessage to show next line				
				}
				else if (bRefreshTableContent) {
					mpReturn.put(DCLConstants.ACTION_JAVASCRIPT, DCLUtil.encodeFunctionForJavaScript(context, false, "topWindowRefresh"));					
				}
				else {
					mpReturn.put(DCLConstants.ACTION_JAVASCRIPT, DCLUtil.encodeFunctionForJavaScript(context, false, "setContentFrameLocation", saObjectId[0]));
				}


			}
			return mpReturn;
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method is used to get periodic review interval value on change of periodic review enabled
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return Map return the map to execute JSP to call JavaScript
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map getPeriodicReviewInterval(Context context,String[] args) throws DCLException 
	{ 
		try {
			String strInterVal = DomainConstants.EMPTY_STRING;
			Map<String,String> mpReturn = new HashMap<String,String> ();
			Map hmParamMap = (Map) JPO.unpackArgs(args);
			String[] sPropertyKey = (String[]) hmParamMap.get("propertyKey");
			String[] strSelectedType = (String[]) hmParamMap.get("selectedType");
			String strKey = sPropertyKey[0];

			mpReturn.put(DCLConstants.ACTION_AJAX, getPeriodicReviewIntervalforType(context, strSelectedType[0], strKey));
			return mpReturn;
		}
		catch (Exception e) {
			throw new DCLException();
		}
	}

	private static String getPeriodicReviewIntervalforType(Context context, String type,String strPropertyKey) throws Exception
	{
		try{
			String strKeyForType=DomainObject.EMPTY_STRING;
			try{
				strKeyForType=EnoviaResourceBundle.getProperty(context, type.replace(" ", "") + "."+strPropertyKey);
			}catch(Exception e){
				String command = "print Type '$1' select $2 dump";
				String strTypeName= MqlUtil.mqlCommand(context, command,type,"derived");
				if(!UIUtil.isNullOrEmpty(strTypeName)){
					strKeyForType=getPeriodicReviewIntervalforType( context,  strTypeName,strPropertyKey); 
				}
			}
			return strKeyForType;
		}catch(Exception e1 ){
			throw new DCLException (e1.getLocalizedMessage());
		}
	}


	/**
	 * Access method is used to show Delete All and Delete This version Command
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return boolean return true which shows command in action menu else hide the command
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public boolean showDeleteCommand (Context context,String[] args) throws DCLException {
		boolean isShow = false;
		boolean bAllowVersion = false;
		try {
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			Map hmProgram = (Map) JPO.unpackArgs(args);
			String strDocId = (String) hmProgram.get(DCConstants.OBJECTID);
			String strPolicyname = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENTS );
			Map mpPolicy = DCLUtil.getInfo(context, strDocId, new StringList(DomainConstants.SELECT_POLICY));
			String strPolicy = (String) mpPolicy.get(DomainConstants.SELECT_POLICY);
			if(strPolicy.equalsIgnoreCase(strPolicyname)) {
				String strPolicyStateName = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, strPolicyname,
						DCLConstants.SYMBOLIC_STATE_PRELIMINARY);
				if(PolicyUtil.checkState(context, strDocId, strPolicyStateName, PolicyUtil.EQ) && !documentService.hasCOConnected(context, strDocId)) { 
					bAllowVersion = true;
				}
			}
			else {
				bAllowVersion = true;
			}
			if(bAllowVersion) {
				isShow = new ${CLASS:emxCommonDocument}(context, args).allowFileVersioning(context, args);
			}
		}
		catch (Exception e) {
			throw new DCLException();
		}
		return isShow;
	}
	/**
	 * Method is used to write history of "Reason for change" field when controlled document object is in Approval state
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public void writeHistoryForreasonForChange(Context context,String[] args) throws DCLException {
		try {
			String strReasonForChange = EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.Lable.ReasonForChange");
			StringBuilder sbHistory = new StringBuilder();
			Map hmProgram = (Map) JPO.unpackArgs(args);
			Map hmParam = (Map) hmProgram.get(DCLConstants.PARAMMAP);
			String strValue = (String) hmParam.get(DCLConstants.NEW_VALUE);
			HistoryAuditTrailService auditTrailService = DCLServiceUtil.getHistoryAuditTrailService(context);
			auditTrailService.customHistoryUpdation(context, (String) hmParam.get(DCConstants.OBJECTID), strReasonForChange, strValue,
					DCLConstants.HISTORY_MODIFY_ACTION);
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	/**
	 * post process URL method to edit details of document
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return Map key-value pair to call JavaScript function
	 * @throws DDCLException if operation fails
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> editDocumentDetails(Context context, String[] args) throws DCLException {
		Map<String,String> mpReturn = new HashMap<String,String>();
		try {
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			String attributeTrainingEnabled = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_TRAINING_ENABLED);
			Map<?,?> programMap = (Map<?,?>) JPO.unpackArgs(args);
			String[] strObjectId = (String[]) programMap.get(DCConstants.OBJECTID);
			String strDocumentId = strObjectId[0];
			DomainObject documentObject = DomainObject.newInstance(context, strDocumentId);
			String[] saRespOrg = (String[]) programMap.get(DCLConstants.ResponsibleOrganization);
			String strRespOrg = saRespOrg[0];
			String isFromRMB[] = (String[]) programMap.get("isFromRMB");
			String strUrl = DomainConstants.EMPTY_STRING;
			String strTrainingEnabled = DomainConstants.EMPTY_STRING;
			String[] strArrTrainingEnabled = (String[]) programMap.get("TrainingEnabled");
			if(!DCLUtil.isNullOrEmpty(strArrTrainingEnabled)){
				strTrainingEnabled = strArrTrainingEnabled[0];
				if(!UIUtil.isNullOrEmpty(strTrainingEnabled))
					documentObject.setAttributeValue(context, attributeTrainingEnabled, strTrainingEnabled);
			}
			if (!UIUtil.isNullOrEmpty(strRespOrg)) {
				documentService.updateResponsibleOrganization(context, strDocumentId, strRespOrg);
			}

			if (null != isFromRMB && DCLConstants.TRUE.equalsIgnoreCase(isFromRMB[0])) {
				strUrl = "../common/emxPortal.jsp?portal=DCDocumentsView&header=enoDocumentCommon.Header.MyDocumentsView&suiteKey=DocumentCommon&StringResourceFileId=enoDocumentCommonStringResource&SuiteDirectory=documentcommon&objectId="+strObjectId[0];
				DCLUtil.encodeFunctionForJavaScript(context, false, "editDocumentDetails", strUrl,isFromRMB[0]);
			}
			else {
				strUrl = "../common/emxPortal.jsp?portal=DCLDocumentPortal&displayCDMFileSummary=true&objectId="+strObjectId[0];
				DCLUtil.encodeFunctionForJavaScript(context, false, "editDocumentDetails", strUrl,isFromRMB[0]);
			}

			String strMessage = EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.AlertMsg.TraineesWillBeDeletedAsTrainingDisabled");

			mpReturn.put(DCLConstants.ACTION_JAVASCRIPT, "editDocumentDetails('"+strUrl+"','"+isFromRMB[0]+"','"+strTrainingEnabled+"','"+strMessage+"')");
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		return mpReturn;
	}
	/**
	 * Method is used to disable periodic review interval and subject matter
	 * expert field on form This method is called from programHTMLOutput and
	 * which is used to disable periodic review interval and subject matter
	 * expert fields, when Periodic Review Enabled is No
	 * 
	 * @param context
	 *            the ENOVIA <code>Context</code> object.
	 * @param args
	 *            holds packed arguments
	 * @return String returns the HTML code and calls the JavaScript function.
	 * @exclude
	 */
	public String disableSMEAndPeriodicIntevalField(Context context,String[] args) throws DCLException 
	{
		try
		{
			Map<?,?> programMap = (Map<?,?>) JPO.unpackArgs(args);
			Map requestMap = (Map)programMap.get("requestMap");
			String selTemplateId=(String)requestMap.get("selTemplateId");

			String strAutoNaming=DCLConstants.OPTIONAL;
			if(UIUtil.isNotNullAndNotEmpty(selTemplateId))
			{
				DomainObject dobjDoc=DomainObject.newInstance(context,selTemplateId);
				strAutoNaming=dobjDoc.getInfo(context, DomainObject.getAttributeSelect(PropertyUtil.getSchemaProperty(context,DCLConstants.SYMBOLIC_ATTRIBUTE_DOCUMENT_AUTONAMING)));
			}

			return "<script>hideSMEAndIntervalFields('"+selTemplateId+"','"+strAutoNaming+"')</script>";
		}
		catch(Exception ex)
		{
			throw new DCLException(ex);
		}

	}

	/**
	 * Column Type ProgramHtml for showing list of Access
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds program map
	 * @return List of access values of people
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public StringList getListOfAccessForDocument(Context context,String args[]) throws DCLException
	{
		try {
			Map<?,?> programMap = (Map<?,?>) JPO.unpackArgs(args);
			MapList objectList=(MapList) programMap.get(DCConstants.OBJECTLIST);
			StringList slAccess=new StringList();
			for(Object objMap:objectList)
			{
				Map<String,String> mObjectMap=(Map) objMap;
				String strobjectId=mObjectMap.get(DomainConstants.SELECT_ID);
				StringBuilder sBuff=new StringBuilder();
				sBuff.append("<select name='");
				sBuff.append(XSSUtil.encodeForHTMLAttribute(context, strobjectId));
				sBuff.append("'><option value=\'");
				sBuff.append(DCLConstants.READ);
				sBuff.append("\'>");
				sBuff.append(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
						"enoDocumentControl.Access.Read"));
				sBuff.append("</option><option value=\'");
				sBuff.append(DCLConstants.READ_WRITE);
				sBuff.append("\'>");
				sBuff.append(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
						"enoDocumentControl.Access.ReadWrite"));
				sBuff.append("</option><option value=\'");
				sBuff.append(DCLConstants.ADD);
				sBuff.append("\'>");
				sBuff.append(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
						"enoDocumentControl.Access.Add"));
				sBuff.append("</option><option value=\'");
				sBuff.append(DCLConstants.ADD_REMOVE);
				sBuff.append("\'>");
				sBuff.append(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
						"enoDocumentControl.Access.AddRemove"));
				sBuff.append("</option><option value=\'");
				sBuff.append(DCLConstants.REMOVE);
				sBuff.append("\'>");
				sBuff.append(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
						"enoDocumentControl.Access.Remove"));
				sBuff.append("</option><option value=\'");
				sBuff.append(DCLConstants.NONE);
				sBuff.append("\'>");
				sBuff.append(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
						"enoDocumentControl.Access.None"));
				sBuff.append("</option></select>");

				slAccess.add(sBuff.toString());
			}
			return slAccess;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Range Program for getting range of access for Person
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args
	 * @return Map of Key field choices and field display choices with values as StringList
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public Map getRangeofAccess(Context context,String args[]) throws DCLException
	{
		try {
			Map programMap=(Map) JPO.unpackArgs(args);
			Map requestMap=(Map) programMap.get(DCLConstants.REQUESTMAP);
			String strlanguage=(String) requestMap.get(DCLConstants.LANGUAGE_STR);
			StringList slAccessDisplayList = new StringList();

			slAccessDisplayList.add(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.Access.Read"));
			slAccessDisplayList.add(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.Access.ReadWrite"));
			slAccessDisplayList.add(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.Access.Add"));
			slAccessDisplayList.add(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.Access.AddRemove"));
			slAccessDisplayList.add(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.Access.Remove"));
			slAccessDisplayList.add(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.Access.None"));

			StringList slAccessChoiceList = new StringList();
			slAccessChoiceList.add(DCLConstants.READ);
			slAccessChoiceList.add(DCLConstants.READ_WRITE);
			slAccessChoiceList.add(DCLConstants.ADD);
			slAccessChoiceList.add(DCLConstants.ADD_REMOVE);
			slAccessChoiceList.add(DCLConstants.REMOVE);
			slAccessChoiceList.add(DCLConstants.NONE);
			Map mRangeMap = new HashMap();
			mRangeMap.put(DCLConstants.FIELD_CHOICES, slAccessChoiceList);
			mRangeMap.put(DCLConstants.FIELD_DISPLAY_CHOICES,slAccessDisplayList);
			return mRangeMap;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}

	}

	/**
	 * Deletes or simulates the deletion of Documents
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param saArrDocIds array of ids
	 * @param bDryRun true if documents not to be deleted and just simulation for validation
	 * @return Error Message
	 * @throws DCLException if operation fails
	 */
	private StringBuilder deleteDocList(Context context, String[] saArrDocIds, boolean bDryRun) throws DCLException{
		try{
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			Map mreturnInavalidDocId=documentService.deleteDocument(context, saArrDocIds, bDryRun);         

			String strInvalidDocumentMessage = DomainConstants.EMPTY_STRING;
			String strStateMessage = DomainConstants.EMPTY_STRING;
			String strCOMessage = DomainConstants.EMPTY_STRING;
			String strRefrenceMessage = DomainConstants.EMPTY_STRING;

			MapList mListofWrongStateId=(MapList) mreturnInavalidDocId.get(DCLConstants.STATE);
			MapList mListofCOConnected=(MapList) mreturnInavalidDocId.get(DCLConstants.CO);
			MapList mListofRefrencedDocuments =(MapList) mreturnInavalidDocId.get(DCLConstants.REFERENCE_DOCUMENT);
			MapList mListofNonAcessDocuments =(MapList) mreturnInavalidDocId.get(DCLConstants.ACCESS);
			MapList mListOfInvalidDocuments = (MapList)mreturnInavalidDocId.get(DCLConstants.INVALIDDOCUMENT);


			StringBuilder sBuffMessage=new StringBuilder();
			StringList slInvalidDocument=getErrorMessage(context, mListOfInvalidDocuments);
			if (slInvalidDocument.size() > 0) {
				strInvalidDocumentMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.InvalidDocument",
						new String[] { slInvalidDocument.toString() }, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				sBuffMessage.append(strInvalidDocumentMessage).append("\n");
			}
			StringList slNoAccessDocNameList=getErrorMessage(context, mListofNonAcessDocuments);
			if (slNoAccessDocNameList.size() > 0) {
				String strNoAccessMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.NoDocumentAccess",
						new String[] { slNoAccessDocNameList.toString() }, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				sBuffMessage.append(strNoAccessMessage).append("\n");
			}

			StringList slStateNameList=getErrorMessage(context, mListofWrongStateId);
			if (slStateNameList.size() > 0) {
				strStateMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.DocumentWrongState",
						new String[] { slStateNameList.toString() }, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				sBuffMessage.append(strStateMessage).append("\n");
			}

			StringList slCONameList=getErrorMessage(context, mListofCOConnected);
			if (slCONameList.size() > 0) {
				strCOMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.COConnected",
						new String[] { slCONameList.toString() }, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				sBuffMessage.append(strCOMessage).append("\n");
			}

			StringList slReferencDocNameList=getErrorMessage(context, mListofRefrencedDocuments);
			if (slReferencDocNameList.size() > 0) {
				strRefrenceMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.ReferenceConnected",
						new String[] { slReferencDocNameList.toString() }, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				sBuffMessage.append(strRefrenceMessage).append("\n");
			}

			return sBuffMessage;
		} catch (Exception e) {
			throw new DCLException(e);
		}
	}

	/**
	 * Method to delete selected documents
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args programMap
	 * @return Error message in case of failure
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public String deleteDocuments(Context context, String[] args) throws DCLException{
		try {
			Map programMap = (Map) JPO.unpackArgs(args);
			String[] strArrDocIds = (String[])programMap.get(DCLConstants.OBJECTID);
			StringBuilder sBuffMessage = deleteDocList(context, strArrDocIds, false);
			return sBuffMessage.toString();
		} catch (Exception e) {
			throw new DCLException(e);
		}
	}

	/**
	 * Method to check if documents can be deleted
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param list of document ids to be deleted
	 * @return Error message if document(s) cannot be deleted
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public String checkDeleteDocuments(Context context, String[] args) throws DCLException{
		try {
			StringBuilder sBuffMessage = deleteDocList(context, args, true);
			return sBuffMessage.toString();
		} catch (Exception e) {
			throw new DCLException(e);
		}
	}

	/**
	 * This method gets the Name and revision for document which can not be deleted 
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param mListofWrongId MapList of Map for document name and revision 
	 * @return StringLis of Name and revision
	 * @exclude
	 */
	public StringList getErrorMessage(Context context, MapList mListofWrongId) {
		StringList slDocNameList=new StringList();
		for (Object objMap : mListofWrongId) {
			Map mObj=(Map)objMap;
			String strName=(String)mObj.get(DomainConstants.SELECT_NAME);
			String strRevision=(String)mObj.get(DomainConstants.SELECT_REVISION);
			if(!UIUtil.isNullOrEmpty(strName))
				slDocNameList.add(strName+" "+strRevision);

		}
		return slDocNameList;
	}
	/**
	 * Method to get list of Reference Documents
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args
	 * @return MapList of refernceDocument
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.matrixone.apps.framework.ui.ProgramCallable
	public MapList getReferenceDocuments(Context context, String args[]) throws DCLException
	{
		try {
			Map programMap=(Map) JPO.unpackArgs(args);
			String strObjectId=(String)programMap.get(DCConstants.OBJECTID);
			MapList mlReferenceDocList = new MapList();
			MapList mlRefrencedDocuments=DCDocument.getReferenceDocuments(context,strObjectId);
			for (Object object : mlRefrencedDocuments) {
				Map mpReferenceDocs = (Map) object;
				if (!"to".equals((String) mpReferenceDocs.get(DomainRelationship.SELECT_DIRECTION))) {
					mlReferenceDocList.add(mpReferenceDocs);
				}
			}
			return mlReferenceDocList;
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	/**
	 * Method to add reference document to existing document
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args object id of document
	 * @return Map for JavaDcript to refresh table
	 * @throws DCLException if operation fails
	 * @exclude
	 */

	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> addReferenceDocuments(Context context, String args[]) throws DCLException
	{
		try {
			Map programMap = (Map) JPO.unpackArgs(args);
			String[] strObjectId=(String[])programMap.get(DCConstants.OBJECTID);
			String strTableRowIds[] =  (String[])programMap.get(DCLConstants.EMX_TABLE_ROW_ID);
			StringBuilder strSelectedIds=new StringBuilder();
			StringList sListToDocIds=new StringList();
			Map<String,String> mReturnMap=new HashMap<String,String>();
			for(String strRowIds:strTableRowIds)
			{
				try {
					String strRowId=strRowIds;
					TableRowId tableRowId=new TableRowId(strRowId);
					String strDocObjectId=tableRowId.getObjectId();
					strSelectedIds.append(strDocObjectId).append("|");
					sListToDocIds.add(strDocObjectId);

				} catch (Exception e) {
					throw new DCLException(e.getMessage()); 
				}
			}
			if(!DCUtil.ifReferenceDocumentCategorizationEnabled(context)){
				String strArrDocIds[]=new String[sListToDocIds.size()];
				for(int i=0;i<sListToDocIds.size();i++)
				{
					strArrDocIds[i]=(String) sListToDocIds.get(i);
				}
				DCDocument.addReferenceDocuments(context,strObjectId[0],strArrDocIds);
				DCLUtil.encodeFunctionForJavaScript(context, false, "addReferenceDocuments");
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT,"addReferenceDocuments()");
			}else{   
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "connectReferenceDocumentWithCategory('"+strObjectId[0]+"','"+strSelectedIds.toString()+"')");
			}

			return mReturnMap;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> connectReferenceDocument(Context context, String args[]) throws DCLException
	{
		try {
			Map programMap = (Map) JPO.unpackArgs(args);
			String[] strObjectId=(String[])programMap.get(DCConstants.OBJECTID);
			String[] selectedIds = (String[]) programMap.get("selectedIds");
			List<String> slSelectedIds=new StringList();
			List<String> slRefDocIds=new StringList();
			if(null!=selectedIds){
				slSelectedIds=FrameworkUtil.split(selectedIds[0],"|"); 

			}
			for(String strId:slSelectedIds)
			{
				if(!DCLUtil.isNullOrEmpty(strId)){
					slRefDocIds.add(strId);
				}

			}
			int count=0;
			String strArrDocIds[]=new String[slRefDocIds.size()];
			for(String strId:slRefDocIds)
			{
				if(!DCLUtil.isNullOrEmpty(strId)){
					strArrDocIds[count]=strId;
					count++;
				}
			}

			DomainObject dObjDoc = DomainObject.newInstance(context, strObjectId[0]);
			String strRelRefrenceDocument=PropertyUtil.getSchemaProperty(context,DomainSymbolicConstants.SYMBOLIC_relationship_ReferenceDocument);
			Map mRelData=DomainRelationship.connect(context,dObjDoc,new RelationshipType(strRelRefrenceDocument), true,strArrDocIds);
			for(int i=0;i<strArrDocIds.length;i++){
				String strRelId=(String)mRelData.get(strArrDocIds[i]);
				String strNewValue=DomainObject.EMPTY_STRING;
				String[] saCategoryValue=(String[]) programMap.get("RefDoc$"+strArrDocIds[i]);
				if(null!=saCategoryValue)
					strNewValue=saCategoryValue[0];
				DomainRelationship.setAttributeValue(context, strRelId, "Document Classification", strNewValue);
			}
			Map<String,String> mReturnMap=new HashMap<String,String>();
			mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT,"connectReferenceDocumentWithCategoryPostRefresh()"); 
			return mReturnMap;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method to remove Referenced Documents
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param objectId of Document
	 * @return Map of JavaScript to refresh Table
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public Map<String,String> removeReferenceDocuments(Context context, String args[]) throws DCLException {
		try {
			Map<?,?> programMap = (Map<?,?>) JPO.unpackArgs(args);
			String strTableRowIds[] =  (String[])programMap.get(DCLConstants.EMX_TABLE_ROW_ID);
			StringList sListToRelIds = new StringList();
			for(String strRowIds:strTableRowIds)
			{
				String strRowId=strRowIds;

				TableRowId tableRowId= new TableRowId(strRowId);
				String strRelId=tableRowId.getRelationshipId();
				sListToRelIds.add(strRelId);
			}
			String strArrDocIds[]=new String[sListToRelIds.size()];
			for(int i=0;i<sListToRelIds.size();i++)
			{
				strArrDocIds[i]=(String) sListToRelIds.get(i);
			}
			DomainRelationship.disconnect(context,strArrDocIds);
			Map<String,String> mReturnMap = new HashMap<String,String>();
			DCLUtil.encodeFunctionForJavaScript(context, false, "removeReferenceDocuments");
			mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT,"removeReferenceDocuments()");
			return mReturnMap;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}

	}
	/**
	 * This method is ColumnType programHTMLOutput 
	 *          It shows higher revision image if there exist higher revision of object
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param objectList to get id for Reference Document
	 * @return StringList of images for higher revision objects
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public StringList hasHigherRevisions(Context context, String args[]) throws DCLException
	{
		try {
			Map<?,?> programMap = (Map<?,?>) JPO.unpackArgs(args);
			MapList objectList=(MapList) programMap.get(DCConstants.OBJECTLIST);
			StringList slRevisions=new StringList();
			for(Object objMap:objectList)
			{
				Map mObjectMap=(Map) objMap;
				String strobjectId=(String) mObjectMap.get(DomainConstants.SELECT_ID);
				DomainObject dObj=DomainObject.newInstance(context,strobjectId);
				String objectId=dObj.getNextRevision(context).getObjectId(context);
				StringBuilder sBuff=new StringBuilder();
				if(!UIUtil.isNullOrEmpty(objectId))
				{
					sBuff.append("<img border=\"0\" src=\"../common/images/iconStatusGreen.gif\"></img>");
				}
				else
					sBuff.append(DomainConstants.EMPTY_STRING);
				slRevisions.add(sBuff.toString());
			}
			return slRevisions;
		} 
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method to exclude document that are already added as Referenced Document
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param objectId of Document
	 * @return StringList of documents to be excluded
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.matrixone.apps.framework.ui.ExcludeOIDProgramCallable
	public StringList excludeReferenceDocument(Context context, String args[]) throws DCLException
	{
		try {
			Map<?,?> programMap = (Map<?,?>) JPO.unpackArgs(args);
			String strObjectId=(String)programMap.get(DCConstants.OBJECTID);
			StringList slexcludeDocument=new StringList();
			DomainObject dobj=DomainObject.newInstance(context,strObjectId);
			MapList mlRefrencedDocList=DCDocument.getReferenceDocuments(context, strObjectId);
			for(Object objMap:mlRefrencedDocList)
			{
				Map mobjDocMap=(Map) objMap;
				String strDocId=(String) mobjDocMap.get(DomainConstants.SELECT_ID);
				slexcludeDocument.add(strDocId);
			}
			slexcludeDocument.add(strObjectId);
			return slexcludeDocument;
		} 
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}

	}
	/**
	 * Method is used to create copy of existing document object
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return Map Key-Value pair for execute JavaScript
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable 
	public Map<String,String> copyExistingDocument(Context context, String[] args) throws DCLException {
		Map<String,String> mpReturn = new HashMap<String,String>();
		String strCopiedDocument= getCopiedDocumentObject(context, args);
		DCLUtil.encodeFunctionForJavaScript(context, false, "copyExistingDocument",strCopiedDocument);
		String strIsOneSearchEnabled = DCLConstants.TRUE;
		try{
			strIsOneSearchEnabled =	EnoviaResourceBundle.getProperty(context, DCLConstants.SEARCH_MODE);
		}
		catch(Exception e){}
		mpReturn.put(DCLConstants.ACTION_JAVASCRIPT, "copyExistingDocument('"+strCopiedDocument+"','"+strIsOneSearchEnabled+"')");
		return mpReturn;
	}

	/**
	 * Method is used to create copy of selected document object
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return Map Key-Value pair for execute JavaScript
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> copySelectedDocument(Context context, String[] args) throws DCLException {
		Map<String,String> mpReturn = new HashMap<String,String>();
		String strCopiedDocument = getCopiedDocumentObject(context, args);
		DCLUtil.encodeFunctionForJavaScript(context, false, "copySelectedDocument",strCopiedDocument);
		mpReturn.put(DCLConstants.ACTION_JAVASCRIPT,"copySelectedDocument('"+strCopiedDocument+"')");
		return mpReturn;
	} 
	/**
	 * Method is used to get the created copied document object id
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return String object id of copied object and Message. Example <Object Id|Message>
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	private String getCopiedDocumentObject(Context context,String[] args) throws DCLException
	{
		String strNewDocId = DomainConstants.EMPTY_STRING; 
		String strSelectedDocId = DomainConstants.EMPTY_STRING;
		try
		{
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			Map<?,?> programMap = (Map<?,?>) JPO.unpackArgs(args);
			String arrTableRowIds[] =  (String[])programMap.get(DCLConstants.EMX_TABLE_ROW_ID);
			for(String strRowIds:arrTableRowIds)
			{
				String strRowId=strRowIds;
				TableRowId tableRowId=new TableRowId(strRowId);
				strSelectedDocId=tableRowId.getObjectId();
			}
			// create the copy of selected and existing document object
			strNewDocId = documentService.copySelectedAndExisting(context,strSelectedDocId);
			ArrayList alPersons = documentService.replicateSubscriptions(context, strSelectedDocId, strNewDocId, true, false);

			StringBuilder sb = new StringBuilder(128);
			sb.append(strNewDocId);
			if(alPersons != null && alPersons.size()>0){
				sb.append(DCLConstants.PIPE_SEPARATOR);
				sb.append(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
						"enoDocumentControl.Alert.SubscribersNotReplicated"));
				sb.append("\n");
				sb.append(alPersons.toString().replaceAll(DCLConstants.COMMA, DomainConstants.EMPTY_STRING));
			}
			return sb.toString();
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Returns HTML link to open organization properties in popup 
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args hold program map with object id
	 * @return HTML link to open organization properties in popup 
	 * @throws DCLException if operation fails
	 */
	public String getOrganizationLink(Context context,String[] args) throws DCLException
	{
		StringBuilder sbLink = new StringBuilder(256);
		try
		{
			Map mpProgram = (Map) JPO.unpackArgs(args);
			Map mpParam = (Map) mpProgram.get(DCLConstants.PARAMMAP);
			Map mpRequest = (Map) mpProgram.get(DCLConstants.REQUESTMAP);
			String strReportFormat = (String) mpRequest.get(DCConstants.REPORTFORMAT);
			String strPFMode = (String) mpRequest.get(DCConstants.PFMODE);
			DomainObject domObj = DomainObject.newInstance(context, (String) mpParam.get(DCLConstants.OBJECTID));
			StringList slSelects = new StringList(3);
			slSelects.add(DomainConstants.SELECT_NAME);
			slSelects.add(DomainConstants.SELECT_ORGANIZATION);
			slSelects.add(DomainConstants.SELECT_TYPE);
			Map mpInfo = domObj.getInfo(context, slSelects);

			String strOrgName = (String)mpInfo.get(DomainConstants.SELECT_ORGANIZATION);
			if(!UIUtil.isNullOrEmpty(strReportFormat))
			{
				sbLink.append(strOrgName);
			}
			else if(DCLConstants.TRUE.equalsIgnoreCase(strPFMode))
			{
				String strType = FrameworkUtil.getAliasForAdmin(context, "type",(String)mpInfo.get(DomainConstants.SELECT_TYPE), true);
				String typeIcon = EnoviaResourceBundle.getProperty(context,"emxFramework.smallIcon." + strType);
				sbLink.append("<img border=\"0\" src=\"images/").append(XSSUtil.encodeForHTMLAttribute(context, typeIcon)).append("\">");
				sbLink.append(strOrgName);
			}
			else
			{
				sbLink.append(DCUtil.getObjectLink(context, DCLUtil.getOrganizationId(context, strOrgName), strOrgName));  
			}

			return sbLink.toString();
		}
		catch (Exception e) {
			throw new DCLException(e);
		}
	}
	/**
	 * Returns HTML link to open organization properties in popup
	 * 
	 * @param context
	 *            the ENOVIA <code>Context</code> object.
	 * @param args
	 *            hold program map with object id
	 * @return HTML link to open organization properties in popup
	 * @throws DCLException
	 *             if operation fails
	 */
	public String getSummaryReportOrganizationLink(Context context, String[] args) throws DCLException {
		StringBuilder sbLink = new StringBuilder(256);
		try {
			Map mpProgram = (Map) JPO.unpackArgs(args);
			String[] strObjectId=(String[]) mpProgram.get(DCLConstants.OBJECTID);

			DomainObject domObj = DomainObject.newInstance(context, strObjectId[0]);
			StringList slSelects = new StringList(3);
			slSelects.add(DomainConstants.SELECT_NAME);
			slSelects.add(DomainConstants.SELECT_ORGANIZATION);
			slSelects.add(DomainConstants.SELECT_TYPE);
			Map mpInfo = domObj.getInfo(context, slSelects);

			String strOrgName = (String) mpInfo.get(DomainConstants.SELECT_ORGANIZATION);
			sbLink.append(strOrgName);

			return sbLink.toString();
		}
		catch (Exception e) {
			throw new DCLException(e);
		}
	}
	/**
	 * programHTMLOutput Method is used to get the link of owner
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return String returns the HTML code to dispaly link for owner
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public String getOwnerLink(Context context,String[] args) throws DCLException
	{
		String strOwnerLink = DomainConstants.EMPTY_STRING;
		StringBuilder sbOwner = new StringBuilder(256);
		try
		{
			Map mpProgram = (Map) JPO.unpackArgs(args);
			Map mpParam = (Map) mpProgram.get(DCLConstants.PARAMMAP);
			Map mpRequest = (Map) mpProgram.get(DCLConstants.REQUESTMAP);
			String strReportFormat = (String) mpRequest.get(DCConstants.REPORTFORMAT);
			String strPFMode = (String) mpRequest.get(DCConstants.PFMODE);

			StringList slObjectSelect=new StringList();
			slObjectSelect.add(DomainConstants.SELECT_OWNER);
			Map mDocInfo= DCLUtil.getInfo(context, (String) mpParam.get("objectId"), slObjectSelect);

			String strName = (String) mDocInfo.get(DomainConstants.SELECT_OWNER);
			if(UIUtil.isNotNullAndNotEmpty(strName))
			{
				String strOwnerBus = DCLUtil.mqlCommand(context, "temp query bus $1 $2 $3 select $4 $5", true, "Person", strName, "-", "id", "dump");
				if(UIUtil.isNotNullAndNotEmpty(strOwnerBus)){						
					String strOwnerId = PersonUtil.getPersonObjectID(context, strName);
					strName = PersonUtil.getFullName(context, strName);
					if (UIUtil.isNullOrEmpty(strReportFormat)&&UIUtil.isNotNullAndNotEmpty(strName)) {
						strName = DCUtil.getObjectLink(context, strOwnerId, strName);
					}
				}

			}
			return strName != null ? strName : DomainConstants.EMPTY_STRING;
		}
		catch (Exception e) {
			throw new DCLException(e);
		}
	}
	/**
	 * programHTMLOutput Method is used to get the link of owner
	 * 
	 * @param context
	 *            the ENOVIA <code>Context</code> object.
	 * @param args
	 *            holds packed arguments
	 * @return String returns the HTML code to dispaly link for owner
	 * @throws DCLException
	 *             if operation fails
	 * @exclude
	 */
	public String getSummaryReportOwnerLink(Context context, String[] args) throws DCLException {
		try {
			Map mpProgram = (Map) JPO.unpackArgs(args);
			StringList slObjectSelect = new StringList();
			slObjectSelect.add(DomainConstants.SELECT_OWNER);
			String[] strObjectId=(String[]) mpProgram.get(DCLConstants.OBJECTID);
			Map mDocInfo = DCLUtil.getInfo(context,strObjectId[0] , slObjectSelect);

			String strName = (String) mDocInfo.get(DomainConstants.SELECT_OWNER);
			if (UIUtil.isNotNullAndNotEmpty(strName)) {
				String strOwnerBus = DCLUtil.mqlCommand(context, "temp query bus $1 $2 $3 select $4 $5", true, PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_Person), strName, "-", DomainConstants.SELECT_ID, "dump");
				if (UIUtil.isNotNullAndNotEmpty(strOwnerBus)) {
					strName = PersonUtil.getFullName(context, strName);
				}
			}

			return strName != null ? strName : DomainConstants.EMPTY_STRING;
		}
		catch (Exception e) {
			throw new DCLException(e);
		}
	}
	/**
	 * Method is used to get the title attribute value from document template
	 * this method is used to pre-populate title attribute value on create new document from template form
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return the title attribute value
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public String getDocumentTitle (Context context,String[] args) throws DCLException
	{
		StringBuilder sbDocTitle = new StringBuilder(256);
		ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
		String strDocTitle = DomainConstants.EMPTY_STRING;
		StringList slObjSelect = new StringList();
		try {
			Map hmProgram = (Map) JPO.unpackArgs(args);
			Map hmRequest = (Map) hmProgram.get(DCLConstants.REQUESTMAP);
			String strSelectedTempId = (String) hmRequest.get("selTemplateId");
			slObjSelect.add("attribute["+DomainConstants.ATTRIBUTE_TITLE+"]");
			Map mpInfo = DCLUtil.getInfo(context,strSelectedTempId,slObjSelect);
			if (mpInfo != null && !mpInfo.isEmpty()) {
				strDocTitle = (String) mpInfo.get("attribute["+DomainConstants.ATTRIBUTE_TITLE+"]");
				sbDocTitle.append("<input type=\"text\"  name=\"TitleDisplay\" id=\"TitleDisplay\" value=\""
						+ XSSUtil.encodeForHTMLAttribute(context, strDocTitle) + "\"/>");
				sbDocTitle.append("<input type=\"hidden\"  id=\"Title\" name=\"Title\" value=\""
						+ XSSUtil.encodeForHTMLAttribute(context, strDocTitle) + "\"/>");
			}

			return sbDocTitle.toString();
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method is used to get the description value from document template
	 * this method is used to pre-populate description value on create new document from template form
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return the description value
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public String getDocumentDescription (Context context,String[] args) throws DCLException
	{
		StringBuilder sbDocDescription = new StringBuilder(256);
		ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
		String strDescription = DomainConstants.EMPTY_STRING;
		try {
			Map hmProgram = (Map) JPO.unpackArgs(args);
			Map hmRequest = (Map) hmProgram.get(DCLConstants.REQUESTMAP);
			String strSelectedTempId = (String) hmRequest.get(DCLConstants.selTemplateId);
			List<String> slSelectList = new StringList(DomainConstants.SELECT_DESCRIPTION);
			Map mpInfo = DCLUtil.getInfo(context,strSelectedTempId,slSelectList);
			strDescription = (String) mpInfo.get(DomainConstants.SELECT_DESCRIPTION);
			sbDocDescription.append("<textarea rows='4' cols='50' id='DescriptionDisplay' name='DescriptionDisplay'>");
			sbDocDescription.append(XSSUtil.encodeForHTML(context, strDescription));
			sbDocDescription.append("</textarea>");
			return sbDocDescription.toString();
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	/**
	 * Method is used to get the "Responsible Organization" from document template
	 * This programHTMLOutput method is used to pre-populate "Responsible Organization" on create new document from template form
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return the responsible organization
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public String getDocumentRespOrg (Context context,String[] args) throws DCLException
	{
		ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
		String strRespOrgDisplayValue = DomainConstants.EMPTY_STRING;
		String strRespOrgDisplayId = DomainConstants.EMPTY_STRING;
		StringList slObjectSelect = new StringList(1);
		try {
			slObjectSelect.add(DomainConstants.SELECT_ORGANIZATION);
			Map hmProgram = (Map) JPO.unpackArgs(args);
			Map hmRequest = (Map) hmProgram.get(DCLConstants.REQUESTMAP);
			String strSelectedTempId = (String) hmRequest.get(DCLConstants.selTemplateId);
			Map mpInfo = DCLUtil.getInfo(context,strSelectedTempId,slObjectSelect);
			strRespOrgDisplayValue = (String) mpInfo.get(DomainConstants.SELECT_ORGANIZATION);
			return strRespOrgDisplayValue;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	/**
	 * Method is used to get the "Periodic Review Enabled" attribute value from document template
	 * this method is used to pre-populate "Periodic Review Enabled" attribute value on create new document from template form
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return the Periodic Review Enabled attribute value
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public String getPeriodicReviewEnabledValue(Context context,String[] args) throws DCLException
	{
		try {
			StringBuilder sbDocReviewEnabled = new StringBuilder(256);
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			String strPeriodicReviewEnabled = DomainConstants.EMPTY_STRING;
			String strDisplayPeriodicReviewEnabled = DomainConstants.EMPTY_STRING;
			String ATTRIBUTE_PERIODIC_REVIEW_ENABLED = PropertyUtil.getSchemaProperty(context,
					DCLConstants.SYMBOLIC_ATTRIBUTE_PERIODIC_REVIEW_ENABLED);
			Map hmProgram = (Map) JPO.unpackArgs(args);
			Map hmRequest = (Map) hmProgram.get(DCLConstants.REQUESTMAP);
			String strSelectedTempId = (String) hmRequest.get(DCLConstants.selTemplateId);
			Map mpInfo = DCLUtil.getInfo(context,strSelectedTempId,new StringList("attribute["+ATTRIBUTE_PERIODIC_REVIEW_ENABLED+"]"));
			strPeriodicReviewEnabled = (String) mpInfo.get("attribute["+ATTRIBUTE_PERIODIC_REVIEW_ENABLED+"]");
			return strPeriodicReviewEnabled;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	/**
	 * Method is used to get the "Periodic Review Interval" attribute value from document template
	 * this method is used to pre-populate "Periodic Review Interval" attribute value on create new document from template form
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return the "Periodic Review Interval" attribute value
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public String getPeriodicReviewIntervalValue (Context context,String[] args) throws DCLException
	{
		StringBuilder sbDocReviewInterval = new StringBuilder(256);
		ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
		String strPeriodicReviewInterval = DomainConstants.EMPTY_STRING;
		String ATTRIBUTE_PERIODIC_REVIEW_INTERVAL = PropertyUtil.getSchemaProperty(context,DCLConstants.SYMBOLIC_ATTRIBUTE_PERIODIC_REVIEW_INTERVAL);
		try {
			Map hmProgram = (Map) JPO.unpackArgs(args);
			Map hmRequest = (Map) hmProgram.get(DCLConstants.REQUESTMAP);
			String strSelectedTempId = (String) hmRequest.get(DCLConstants.selTemplateId);
			Map mpInfo = DCLUtil.getInfo(context,strSelectedTempId,new StringList("attribute["+ATTRIBUTE_PERIODIC_REVIEW_INTERVAL+"]"));
			strPeriodicReviewInterval = (String) mpInfo.get("attribute["+ATTRIBUTE_PERIODIC_REVIEW_INTERVAL+"]");
			return strPeriodicReviewInterval;
		} catch (Exception e) {
			throw new DCLException(e);
		}
	}
	/**
	 * Update program method is used to update the responsible organization value on document
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public void updateResponsibleOrgField (Context context,String[] args) throws DCLException
	{
		try {
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			Map hmProgram = (Map) JPO.unpackArgs(args);
			Map hmParam = (Map) hmProgram.get(DCLConstants.PARAMMAP);
			String strDocId = (String) hmParam.get(DCConstants.OBJECTID);
			String strNewOrgId = (String) hmParam.get(DCLConstants.NEW_OID);
			String strNewOrgValue = (String) hmParam.get(DCLConstants.NEW_VALUE);
			if(UIUtil.isNullOrEmpty(strNewOrgId))
			{
				String TYPE_ORGANIZATION = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_Organization);
				strNewOrgId = DCLUtil.getObjectIdFromTNR(context,TYPE_ORGANIZATION,strNewOrgValue);
			}
			documentService.updateResponsibleOrganization(context, strDocId, strNewOrgId);
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	/**
	 * Update program method is used to update the periodic review interval value on document
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public void updatePeriodicReviewIntervalField (Context context,String[] args) throws Exception
	{
		Map mpAttributes = new HashMap();
		String ATTRIBUTE_PERIODIC_REVIEW_INTERVAL = PropertyUtil.getSchemaProperty(context,DCLConstants.SYMBOLIC_ATTRIBUTE_PERIODIC_REVIEW_INTERVAL);
		Map hmProgram = (Map) JPO.unpackArgs(args);
		Map hmParam = (Map) hmProgram.get(DCLConstants.PARAMMAP);
		String strDocId = (String) hmParam.get(DCConstants.OBJECTID);
		String strNewValue = (String) hmParam.get(DCLConstants.NEW_VALUE);
		mpAttributes.put(ATTRIBUTE_PERIODIC_REVIEW_INTERVAL, strNewValue);
		ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
		documentService.updateAttributes(context, null, strNewValue, null, null, strDocId);
	}

	/**
	 * Edit Access Program used to not allow the access of owner to be editable
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return StringList of true and false according to the list of Person
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public StringList hasEditPersonAcess(Context context,String[] args) throws Exception
	//public List<Boolean> hasEditPersonAcess(Context context,String[] args) throws Exception
	{
		Map<?,?> programMap = (Map) JPO.unpackArgs(args);
		Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
		String strObjectID=(String) requestMap.get(DCConstants.OBJECTID);
		DomainObject dobj = DomainObject.newInstance(context,strObjectID);
		User uDocOwner= dobj.getOwner(context);
		MapList mobjectList = (MapList)programMap.get(DCConstants.OBJECTLIST);
		StringList sAccessList = new StringList();
		// List<Boolean> sAccessList=new ArrayList<>();
		for(Object mObjectMap:mobjectList)
		{
			Map mPerson = (Map) mObjectMap;
			String strPersonObjName=(String) mPerson.get(DomainConstants.SELECT_NAME);
			if(strPersonObjName.equals(uDocOwner.getName()))
				sAccessList.add(String.valueOf(false));
			else
				sAccessList.add(String.valueOf(true));
		}
		return sAccessList;
	}
	/**
	 * Range program method is used to get range values for check in file field
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds nothing
	 * @return Map with range values
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public Map getRangesOfCheckinFileField(Context context,String[] args) throws DCLException
	{
		Map mpReturn = new HashMap();
		StringList slRangeValues = new StringList();
		slRangeValues.add(DCLConstants.YES);
		slRangeValues.add(DCLConstants.NO);
		StringList slDisplayRangeValues = new StringList();
		try {
			slDisplayRangeValues.add(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.Range.Yes"));
			slDisplayRangeValues.add(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.Range.No"));
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		mpReturn.put(DCLConstants.FIELD_CHOICES, slRangeValues);
		mpReturn.put(DCLConstants.FIELD_DISPLAY_CHOICES, slDisplayRangeValues);

		return mpReturn;
	}

	/**
	 * Checks if logged in user is Responsible DCA for the Document.
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param strDocumentObjectId document id
	 * @return true if logged in user is responsible DCA
	 * @throws DCLException if operation fails
	 */
	private boolean isResponsibleDCA(Context context, String strDocumentObjectId)throws DCLException {
		try {
			boolean bIsDCA = false;

			String strDCARole = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_DOCUMENT_CENTER_ADMINISTRATOR);
			String strLeaderRole = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_VPLM_PROJECT_LEADER);
			boolean bHasDCARole = PersonUtil.hasAssignment(context, strDCARole)||PersonUtil.hasAssignment(context, strLeaderRole);

			if(bHasDCARole){
				DomainObject domDocument = DomainObject.newInstance(context, strDocumentObjectId);
				String strDocOrgName = domDocument.getInfo(context, DomainConstants.SELECT_ORGANIZATION);
				String strPersonId = PersonUtil.getPersonObjectID(context);
				DomainObject domPerson = DomainObject.newInstance(context, strPersonId);
				StringList slBusSelects = new StringList(2);
				slBusSelects.add(DomainConstants.SELECT_NAME);
				slBusSelects.add(DomainConstants.SELECT_ID);
				String strRoleSelect = "attribute[" + PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_attribute_ProjectRole)
						+ "]";
				StringList slRelSelects = new StringList(strRoleSelect);
				List<Map> mlOrgs = domPerson.getRelatedObjects(context, DomainConstants.RELATIONSHIP_MEMBER, DomainConstants.TYPE_ORGANIZATION,
						slBusSelects, slRelSelects, true, false, (short) 1, null, null, 0);
				for (Map map : mlOrgs) {
					String strProjectRole = (String)map.get(strRoleSelect);
					StringList slRoles = FrameworkUtil.split(strProjectRole, "~");
					if(slRoles.contains(DCLConstants.SYMBOLIC_ROLE_DOCUMENT_CENTER_ADMINISTRATOR)||slRoles.contains(DCLConstants.SYMBOLIC_ROLE_VPLM_PROJECT_LEADER)){
						String strOrgName = (String) map.get(DomainConstants.SELECT_NAME);
						if(strDocOrgName.equals(strOrgName)){
							bIsDCA = true;
							break;
						}
						else {
							String strOrgId = (String) map.get(DomainConstants.SELECT_ID);
							String strWhr = "name==const\""+strDocOrgName+"\"";
							List<Map> mlParentOrgs=getChildOrganization(context,strOrgId,strWhr);
							if(mlParentOrgs!=null && !mlParentOrgs.isEmpty()){
								bIsDCA = true;
								break;
							}
						}
					}
				}
			}
			return bIsDCA;
		} catch (FrameworkException e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method is used to check Access For context user for PushSubscription
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return boolean returns true if the context user is having access for push subscription
	 * @throws DCLException if operation fails
	 */
	public boolean checkAccessForEnablePushSubscription(Context context, String[] args) throws Exception
	{
		boolean hasAccess=false;
		Map paramMap = (Map)JPO.unpackArgs(args);
		String strObjectid = (String) paramMap.get(DCLConstants.OBJECTID);

		if (null != strObjectid && !"null".equals(strObjectid) && !DomainConstants.EMPTY_STRING.equals(strObjectid)) {
			String strSMERel = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_RELATIONSHIP_SUBJECT_MATTER_EXPERT);  
			DomainObject domainObject=DomainObject.newInstance(context,strObjectid);
			User strOwner=domainObject.getOwner(context);
			String strLoginUser=context.getUser();
			if (strLoginUser.equals(strOwner.toString()) || strLoginUser.equals(domainObject.getInfo(context, "from[" + strSMERel + "].to.name"))
					|| isResponsibleDCA(context, strObjectid)) {
				hasAccess = true;
			}
		}
		return hasAccess;
	}
	/**
	 * Method is used to check Access For context user for to not showing PushSubscription
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return boolean returns true if the context user do not access for push subscription
	 * @throws DCLException if operation fails
	 */
	public boolean checkAccessForDisablePushSubscription(Context context,String[] args) throws Exception
	{
		return !checkAccessForEnablePushSubscription(context,args);
	}


	/**
	 * Returns all connected Change Orders, Change Action and Change Request of Documents on My Documents table
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds Program Map
	 * @return all connected Change Orders of Documents
	 * @throws DCLException if operation fails
	 */
	public Vector<String> getConnectedCOLinks(Context context, String[] args) throws DCLException{
		try {
			//StringList slLinks = new StringList();
			Vector<String> slLinks = new Vector<String>();
			StringBuilder sbLink = new StringBuilder(256);
			StringList sldata = new StringList();
			Map programMap = (Map) JPO.unpackArgs(args);
			Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			List<Map> mlObjectList = (List)programMap.get(DCConstants.OBJECTLIST);
			Map paramList = (Map) programMap.get(DCConstants.PARAMLIST);
			String strReportFormat = (String) paramList.get(DCConstants.REPORTFORMAT);
			final String STR_TYPE_CO = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_ORDER);
			final String STR_TYPE_CA = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_ACTION);
			final String STR_TYPE_CR = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_REQUEST);
			String typeIcon = EnoviaResourceBundle.getProperty(context,"emxFramework.smallIcon." + DCLConstants.SYMBOLIC_TYPE_CHANGE_ORDER);
			String CATypeIcon = EnoviaResourceBundle.getProperty(context,"emxFramework.smallIcon." + DCLConstants.SYMBOLIC_TYPE_CHANGE_ACTION);
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			List<String> slDocIds=new StringList();
			for (Map mDoc : mlObjectList) {
				String strObjectId=(String) mDoc.get(DomainConstants.SELECT_ID);
				slDocIds.add(strObjectId);

			}
			Map mChange = documentService.getConnectedChange(context, slDocIds);
			for (Map mDoc : mlObjectList) {
				String strObjectId=(String) mDoc.get(DomainConstants.SELECT_ID);
				DomainObject docObj = DomainObject.newInstance(context, strObjectId);
				List lChange = (List) mChange.get( strObjectId);
				//List lChange = documentService.getConnectedChange(context, strObjectId);
				//lChange has info in format [[list of CA/CO/CR-1],[list of CA/CO/CR-2]...]
				//Unified code : 


				Map mapCO=new HashMap();
				Map mapCA=new HashMap();
				Map mapCR=new HashMap();
				if(lChange!=null&&lChange.size()>0)
				{

					for(int i=0;i<=lChange.size()-1;i++) {
						mapCO.clear();
						mapCA.clear();
						mapCR.clear();
						List<Map> listTemp = (List<Map>)lChange.get(i);
						for(Object objMap : listTemp){
							Map changeMap = (Map)objMap;
							if(changeMap.size()>0){
								String strChangeType = changeMap.get(DomainObject.SELECT_TYPE).toString();
								if(STR_TYPE_CO.equalsIgnoreCase(strChangeType))
									mapCO = changeMap;
								else if(STR_TYPE_CA.equalsIgnoreCase(strChangeType))
									mapCA = changeMap;
								else if(STR_TYPE_CR.equalsIgnoreCase(strChangeType))
									mapCR = changeMap;
							}

						}
						String strCAID=DomainObject.EMPTY_STRING;
						String strCAName=DomainObject.EMPTY_STRING;
						String strCOID=DomainObject.EMPTY_STRING;
						String strCOName=DomainObject.EMPTY_STRING;
						String strCRID=DomainObject.EMPTY_STRING;
						String strCRName=DomainObject.EMPTY_STRING;
						//CR->CO->CA link or CR->CA link or CO-> CA link
						if(!mapCA.isEmpty()){
							strCAID = (String) mapCA.get(DomainObject.SELECT_ID);	
							strCAName = (String) mapCA.get(DomainObject.SELECT_NAME);

							if(!mapCO.isEmpty()){
								strCOID = (String) mapCO.get(DomainObject.SELECT_ID);	
								strCOName = (String)mapCO.get(DomainObject.SELECT_NAME);
							}
							if(!mapCR.isEmpty()){
								strCRID = (String) mapCR.get(DomainObject.SELECT_ID);	
								strCRName = (String) mapCR.get(DomainObject.SELECT_NAME);
							}
							if(sbLink.length()>0){
								sbLink.append(DCLConstants.COMMA);
							}
							if(UIUtil.isNotNullAndNotEmpty(strReportFormat))
							{
								if(!UIUtil.isNullOrEmpty(strCRID)){
									sbLink.append(strCRName);	//CR name
									sbLink.append(" -> ");
								}
								if(!UIUtil.isNullOrEmpty(strCOID)){
									sbLink.append(strCOName);	//CR name
									sbLink.append(" -> ");
								}
								sbLink.append(strCAName);	//CA Name
							}
							else{
								if(!UIUtil.isNullOrEmpty(strCRID)){
									try{
										sbLink.append(DCUtil.getObjectLink(context, strCRID, strCRName));
									}catch(Exception e){
										sbLink.append(strCRName);
									}
									sbLink.append("<img src=\"../common/images/utilWorkflowGrayArrow.gif\"/>");
								}
								if(!UIUtil.isNullOrEmpty(strCOID)){
									try{
										sbLink.append(DCUtil.getObjectLink(context, strCOID, strCOName));
									}catch(Exception e){
										sbLink.append(strCOName);
									}
									sbLink.append("<img src=\"../common/images/utilWorkflowGrayArrow.gif\"/>");


								}
								try{
									sbLink.append(DCUtil.getObjectLink(context, strCAID, strCAName));
								}catch(Exception e){
									sbLink.append(strCAName);							
								}

							}
						}
					}
				}
				slLinks.add(sbLink.toString());
				sbLink.setLength(0);

			}

			return slLinks;

		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Returns all connected Change Orders and Change Action and Change Request of Document on Documents Properties page
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds Program Map
	 * @return all connected Change Orders of Document
	 * @throws DCLException if operation fails
	 */
	public String getConnectedCOLink(Context context, String[] args) throws DCLException{
		Map<?, ?> programMap;
		StringBuilder sbLink = new StringBuilder(256);
		try {
			programMap = (Map) JPO.unpackArgs(args);
			Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			String strObjectId = (String)requestMap.get(DCConstants.OBJECTID);
			String strPFMode = (String) requestMap.get(DCConstants.PFMODE);
			String strReportFormat = (String) requestMap.get(DCConstants.REPORTFORMAT);
			final String STR_TYPE_CO = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_ORDER);
			final String STR_TYPE_CA = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_ACTION);
			final String STR_TYPE_CR = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_REQUEST);
			final String STR_POLICY_CA = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CA);
			final String STR_STATE_COMPLETE = PropertyUtil.getSchemaProperty(context, "policy", STR_POLICY_CA, DCLConstants.SYMBOLIC_STATE_COMPLETE);
			String typeIcon = EnoviaResourceBundle.getProperty(context,"emxFramework.smallIcon." + DCLConstants.SYMBOLIC_TYPE_CHANGE_ORDER);
			String CATypeIcon = EnoviaResourceBundle.getProperty(context,"emxFramework.smallIcon." + DCLConstants.SYMBOLIC_TYPE_CHANGE_ACTION);
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			DomainObject docObj = DomainObject.newInstance(context, strObjectId);
			List lChange = documentService.getConnectedChange(context, strObjectId);
			//lChange has info in format [[list of CA/CO/CR-1],[list of CA/CO/CR-2]...]
			//will separate the OnGoing change from completed change in below code 
			//so as to put the OnGoing change at the end of the links

			Boolean boolOnGoingChange = Boolean.FALSE;
			String strOnGoingChange=DomainObject.EMPTY_STRING;
			int index=0;
			Map mapCO=new HashMap();
			Map mapCA=new HashMap();
			Map mapCR=new HashMap();
			for(int i=0;i<=lChange.size()-1;i++) {
				List<Map> listTemp = (List<Map>)lChange.get(i);
				if(listTemp.isEmpty())	//for QSD with no change object connected to it
					continue;
				mapCO.clear();
				mapCA.clear();
				mapCR.clear();
				for(Object objMap : listTemp){
					Map changeMap = (Map)objMap;
					String strChangeType = changeMap.get(DomainObject.SELECT_TYPE).toString();
					if(STR_TYPE_CO.equalsIgnoreCase(strChangeType))
						mapCO = changeMap;
					else if(STR_TYPE_CA.equalsIgnoreCase(strChangeType))
						mapCA = changeMap;
					else if(STR_TYPE_CR.equalsIgnoreCase(strChangeType))
						mapCR = changeMap;
				}
				String strCAID=DomainObject.EMPTY_STRING;
				String strCAName=DomainObject.EMPTY_STRING;
				String strCACurrent=DomainObject.EMPTY_STRING;
				String strCOID=DomainObject.EMPTY_STRING;
				String strCOName=DomainObject.EMPTY_STRING;
				String strCRID=DomainObject.EMPTY_STRING;
				String strCRName=DomainObject.EMPTY_STRING;
				//CR->CO->CA link or CR->CA link or CO-> CA link
				if(!mapCA.isEmpty()){
					strCAID = (String) mapCA.get(DomainObject.SELECT_ID);	
					strCAName = (String) mapCA.get(DomainObject.SELECT_NAME);
					strCACurrent = (String) mapCA.get(DomainObject.SELECT_CURRENT);
					if(! STR_STATE_COMPLETE.equalsIgnoreCase(strCACurrent))
						boolOnGoingChange = Boolean.TRUE;	//to denote that CO/CA/CR in current loop is an ongoing change

					if(!mapCO.isEmpty()){
						strCOID = (String) mapCO.get(DomainObject.SELECT_ID);	
						strCOName = (String)mapCO.get(DomainObject.SELECT_NAME);
					}
					if(!mapCR.isEmpty()){
						strCRID = (String) mapCR.get(DomainObject.SELECT_ID);	
						strCRName = (String) mapCR.get(DomainObject.SELECT_NAME);
					}
					if(sbLink.length()>0){
						if(boolOnGoingChange){	//to mark starting index of OnGoing CR/CO/CA link.
							index=sbLink.length();

						}else
							sbLink.append(DCLConstants.COMMA);
					}
					if(UIUtil.isNotNullAndNotEmpty(strReportFormat))
					{
						if(!UIUtil.isNullOrEmpty(strCRID)){
							sbLink.append(strCRName);	//CR name
							sbLink.append(" -> ");
						}
						if(!UIUtil.isNullOrEmpty(strCOID)){
							sbLink.append(strCOName);	//CR name
							sbLink.append(" -> ");
						}
						sbLink.append(strCAName);	//CA Name
					}
					else if(DCLConstants.TRUE.equalsIgnoreCase(strPFMode))
					{
						if(!UIUtil.isNullOrEmpty(strCRID)){
							sbLink.append("<img border=\"0\" src=\"images/").append(XSSUtil.encodeForJavaScript(context, typeIcon)).append("\">");
							sbLink.append(strCRName);
							sbLink.append("<img src=\"../common/images/utilWorkflowGrayArrow.gif\"/>");
						}
						if(!UIUtil.isNullOrEmpty(strCOID)){
							sbLink.append("<img border=\"0\" src=\"images/").append(XSSUtil.encodeForJavaScript(context, typeIcon)).append("\">");
							sbLink.append(strCOName);
							sbLink.append("<img src=\"../common/images/utilWorkflowGrayArrow.gif\"/>");
						}
						sbLink.append("<img src = \"images/").append(XSSUtil.encodeForJavaScript(context, CATypeIcon)).append("\">");
						sbLink.append(strCAName);
					}
					else{
						if(!UIUtil.isNullOrEmpty(strCRID)){
							try{
								sbLink.append(DCUtil.getObjectLink(context, strCRID, strCRName));
							}catch(Exception e){
								sbLink.append(strCRName);
							}
							sbLink.append("<img src=\"../common/images/utilWorkflowGrayArrow.gif\"/>");
						}
						if(!UIUtil.isNullOrEmpty(strCOID)){
							try{
								sbLink.append(DCUtil.getObjectLink(context, strCOID, strCOName));
							}catch(Exception e){
								sbLink.append(strCOName);
							}
							sbLink.append("<img src=\"../common/images/utilWorkflowGrayArrow.gif\"/>");
						}
						try{
							sbLink.append(DCUtil.getObjectLink(context, strCAID, strCAName));
						}catch(Exception e){
							sbLink.append(strCAName);
						}

					}
					//if more that one CO/CA found, move the ongoing CO/CA to the end.
					if(boolOnGoingChange && (lChange.size()>1)){
						strOnGoingChange = sbLink.substring(index, sbLink.length());
						sbLink.delete(index, sbLink.length());
						boolOnGoingChange = Boolean.FALSE;
					}
				}
			}
			if(! UIUtil.isNullOrEmpty(strOnGoingChange)){
				sbLink.append(DCLConstants.COMMA).append(strOnGoingChange);
			}
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		return sbLink.toString();
	}

	/**
	 * Returns all connected Change Orders and Change Action and Change Request
	 * of Document on Documents Properties page
	 * 
	 * @param context
	 *            the ENOVIA <code>Context</code> object.
	 * @param args
	 *            holds Program Map
	 * @return all connected Change Orders of Document
	 * @throws DCLException
	 *             if operation fails
	 */
	public String getSummaryReportConnectedCOLink(Context context, String[] args) throws DCLException {
		Map<?, ?> programMap;
		StringBuilder sbLink = new StringBuilder(256);
		try {
			programMap = (Map) JPO.unpackArgs(args);
			Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			String strObjectId[] = (String[])programMap.get(DCConstants.OBJECTID);
			//	String strPFMode = (String) requestMap.get(DCConstants.PFMODE);
			//String strReportFormat = (String) requestMap.get(DCConstants.REPORTFORMAT);
			final String STR_TYPE_CO = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_ORDER);
			final String STR_TYPE_CA = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_ACTION);
			final String STR_TYPE_CR = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_REQUEST);
			final String STR_POLICY_CA = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CA);
			final String STR_STATE_COMPLETE = PropertyUtil.getSchemaProperty(context, "policy", STR_POLICY_CA, DCLConstants.SYMBOLIC_STATE_COMPLETE);
			String typeIcon = EnoviaResourceBundle.getProperty(context,"emxFramework.smallIcon." + DCLConstants.SYMBOLIC_TYPE_CHANGE_ORDER);
			String CATypeIcon = EnoviaResourceBundle.getProperty(context,"emxFramework.smallIcon." + DCLConstants.SYMBOLIC_TYPE_CHANGE_ACTION);
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			DomainObject docObj = DomainObject.newInstance(context, strObjectId[0]);
			List lChange = documentService.getConnectedChange(context, strObjectId[0]);
			//lChange has info in format [[list of CA/CO/CR-1],[list of CA/CO/CR-2]...]
			//will separate the OnGoing change from completed change in below code 
			//so as to put the OnGoing change at the end of the links

			Boolean boolOnGoingChange = Boolean.FALSE;
			String strOnGoingChange=DomainObject.EMPTY_STRING;
			int index=0;
			Map mapCO=new HashMap();
			Map mapCA=new HashMap();
			Map mapCR=new HashMap();
			for(int i=0;i<=lChange.size()-1;i++) {
				boolOnGoingChange = Boolean.FALSE;
				List<Map> listTemp = (List<Map>)lChange.get(i);
				if(listTemp.isEmpty())	//for QSD with no change object connected to it
					continue;
				mapCO.clear();
				mapCA.clear();
				mapCR.clear();
				for(Object objMap : listTemp){
					Map changeMap = (Map)objMap;
					String strChangeType = changeMap.get(DomainObject.SELECT_TYPE).toString();
					if(STR_TYPE_CO.equalsIgnoreCase(strChangeType))
						mapCO = changeMap;
					else if(STR_TYPE_CA.equalsIgnoreCase(strChangeType))
						mapCA = changeMap;
					else if(STR_TYPE_CR.equalsIgnoreCase(strChangeType))
						mapCR = changeMap;
				}
				String strCAID=DomainObject.EMPTY_STRING;
				String strCAName=DomainObject.EMPTY_STRING;
				String strCACurrent=DomainObject.EMPTY_STRING;
				String strCOID=DomainObject.EMPTY_STRING;
				String strCOName=DomainObject.EMPTY_STRING;
				String strCRID=DomainObject.EMPTY_STRING;
				String strCRName=DomainObject.EMPTY_STRING;
				//CR->CO->CA link or CR->CA link or CO-> CA link
				if(!mapCA.isEmpty()){
					strCAID = (String) mapCA.get(DomainObject.SELECT_ID);	
					strCAName = (String) mapCA.get(DomainObject.SELECT_NAME);
					strCACurrent = (String) mapCA.get(DomainObject.SELECT_CURRENT);
					if(! STR_STATE_COMPLETE.equalsIgnoreCase(strCACurrent))
						boolOnGoingChange = Boolean.TRUE;	//to denote that CO/CA/CR in current loop is an ongoing change

					if(!mapCO.isEmpty()){
						strCOID = (String) mapCO.get(DomainObject.SELECT_ID);	
						strCOName = (String)mapCO.get(DomainObject.SELECT_NAME);
					}
					if(!mapCR.isEmpty()){
						strCRID = (String) mapCR.get(DomainObject.SELECT_ID);	
						strCRName = (String) mapCR.get(DomainObject.SELECT_NAME);
					}
					if(sbLink.length()>0){
						if(boolOnGoingChange){	//to mark starting index of OnGoing CR/CO/CA link.
							index=sbLink.length();

						}else
							sbLink.append(DCLConstants.COMMA);
					}
					if(!UIUtil.isNullOrEmpty(strCRID)){
						sbLink.append(strCRName);	//CR name
						sbLink.append(" -> ");
					}
					if(!UIUtil.isNullOrEmpty(strCOID)){
						sbLink.append(strCOName);	//CR name
						sbLink.append(" -> ");
					}
					sbLink.append(strCAName);	//CA Name

					if(boolOnGoingChange && (lChange.size()>1)){
						strOnGoingChange = sbLink.substring(index, sbLink.length());
						sbLink.delete(index, sbLink.length());
						boolOnGoingChange = Boolean.FALSE;
					}
				}
			}
			if(! UIUtil.isNullOrEmpty(strOnGoingChange)){
				sbLink.append(DCLConstants.COMMA).append(strOnGoingChange);
			}
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		return sbLink.toString();
	}

	/**
	 * Hide CO column in template list table  
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds Program Map
	 * @return false if portal is DCLTemplatesTab
	 * @throws DCLException if operation fails
	 */
	public boolean showCOColumn(Context context, String[] args) throws DCLException{
		boolean bShow = true;
		try {
			Map<?, ?> programMap = (Map) JPO.unpackArgs(args);
			String strPortalCmdName = (String)programMap.get("portalCmdName");
			if("DCLTemplatesTab".equals(strPortalCmdName)){
				bShow = false;
			}
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		return bShow;
	}

	/**
	 * Create Assessment Report and Add it to CO as referenced document.
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds parameter Map
	 * @return JavaScript to run for Change Assessment report creation. 
	 * @throws DCLException if operation fails
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map addAssesmentReport(Context context, String[] args)  throws DCLException{
		try {
			Map programMap = (Map) JPO.unpackArgs(args);
			String strReportTitle = ((String[])programMap.get("reportTitle"))[0];

			Map<String,Object> mpReturn = new HashMap<String,Object>();
			StringBuilder sb = new StringBuilder(256);
			sb.append("function getDisplayRowsAfterFiltering(oXML){\n");
			sb.append(" var rowsToBeShown = null;\n");
			sb.append(" var objectCount = 0;\n");
			sb.append(" var nTotalRows = emxUICore.selectSingleNode(oXML, \"/mxRoot/setting[@name = 'total-rows']\");\n");
			sb.append(" var singleRoot = emxUICore.selectSingleNode(oXML, \"/mxRoot/rows//r[@id ='0']\");\n");
			sb.append(" if(singleRoot){\n");
			sb.append("     rowsToBeShown = emxUICore.selectNodes(oXML, \"/mxRoot/rows//r[ (not(@filter) or @filter != 'true') and (@level = '0' or count(ancestor::r[not(@display) or @display = 'none']) = '0')]\");\n");
			sb.append(" }else{\n");
			sb.append("     rowsToBeShown = emxUICore.selectNodes(oXML, \"/mxRoot/rows//r[ (not(@filter) or @filter != 'true') and ( count(ancestor::r[not(@display) or @display = 'none']) = '0')]\");\n");
			sb.append(" }\n");
			sb.append(" objectCount = rowsToBeShown.length;\n");
			sb.append(" emxUICore.setText(nTotalRows, objectCount);\n");
			sb.append(" return rowsToBeShown;\n");
			sb.append("}\n");

			sb.append("function _getSetting(xml, basePath, name) {\n");
			sb.append(" var nSetting = emxUICore.selectSingleNode(xml, basePath + \"/setting[@name = '\" + name + \"']\");\n");
			sb.append(" if (!nSetting) {\n");
			sb.append("     return null;\n");
			sb.append(" } else {\n");
			sb.append("     return emxUICore.getText(nSetting);\n");
			sb.append(" }\n");
			sb.append("}\n");
			sb.append("function getRequestSetting(oXML, name) {\n");
			sb.append(" return _getSetting(oXML, \"/mxRoot/requestMap\", name);\n");
			sb.append("}\n");

			sb.append("function exportData(oXML){\n");
			sb.append(" var rowGrouping = emxUICore.selectNodes(oXML,\"/mxRoot/setting[@name='groupLevel']\");\n");
			sb.append(" var bGroupingRows = false;\n");
			sb.append(" if(rowGrouping && rowGrouping.length >0){\n");
			sb.append("     bGroupingRows = true;\n");
			sb.append(" }\n");
			sb.append(" outputFormat = \"CSV\";\n");
			sb.append(" var winName = \"listHidden\";\n");
			sb.append(" var groupData = new Array() ;\n");
			sb.append(" var groupRowIndex = new Array() ;\n");
			sb.append(" var tempRowIds = new Array() ;\n");
			sb.append(" var aDisplayRows = getDisplayRowsAfterFiltering(oXML);\n");
			sb.append(" for(var i=0;i<aDisplayRows.length;i++){\n");
			sb.append("     var id = aDisplayRows[i].getAttribute(\"id\");\n");
			sb.append("     if((id.indexOf('L') == -1) && (id.indexOf('cal') == -1)){\n");
			sb.append("         tempRowIds.push(id);\n");
			sb.append("     }\n");
			sb.append("     if((id.indexOf('L') != -1)){\n");
			sb.append("         if(isIE){\n");
			sb.append("             if(aDisplayRows[i].firstChild.text==\" \" || aDisplayRows[i].firstChild.text==\"\"){\n");
			sb.append("                 groupData.push(\"0x08\");\n");
			sb.append("             }else{\n");
			sb.append("                 groupData.push(aDisplayRows[i].firstChild.text);\n");
			sb.append("             }\n");
			sb.append("         }else{\n");
			sb.append("             if(aDisplayRows[i].firstChild.textContent==\" \" || aDisplayRows[i].firstChild.textContent==\"\"){\n");
			sb.append("                 groupData.push(\"0x08\");\n");
			sb.append("             }else{\n");
			sb.append("                 groupData.push(aDisplayRows[i].firstChild.textContent);\n");
			sb.append("             }\n");
			sb.append("         }\n");
			sb.append("         groupData.push(aDisplayRows[i].getAttribute('count'));\n");
			sb.append("         groupRowIndex.push(i);\n");
			sb.append("     }\n");
			sb.append(" }\n");
			sb.append(" var rowIds = tempRowIds.join(\"|\");\n");
			sb.append(" this.parent.document.emxTableForm.rowIds.value = rowIds;\n");
			sb.append(" this.parent.document.emxTableForm.bGroupingRows.value = bGroupingRows;\n");
			sb.append(" if(bGroupingRows){\n");
			sb.append("     this.parent.document.emxTableForm.groupData.value = groupData;\n");
			sb.append("     this.parent.document.emxTableForm.groupRowIndex.value = groupRowIndex;\n");
			sb.append(" }\n");
			sb.append(" var subHeader = getRequestSetting(oXML, 'subHeader');\n");
			sb.append(" var strURL = \"../documentcontrol/enoDCLReport.jsp?exportFormat=\" + outputFormat + \"&subHeader=\" + subHeader+ \"&sbMode=view&reportTitle="
					+ strReportTitle + "\";\n");
			sb.append(" this.parent.document.emxTableForm.target = winName;\n");
			sb.append(" this.parent.document.emxTableForm.action = strURL;\n");
			sb.append(" this.parent.document.emxTableForm.method = \"post\";\n");
			sb.append(" addSecureToken(this.parent.document.emxTableForm);");
			sb.append(" this.parent.document.emxTableForm.submit();\n");
			sb.append(" outputFormat = null;\n");
			sb.append("}\n");

			sb.append("try{\n");
			sb.append(" var contentFrame = findFrame(getTopWindow(),\"listHidden\");\n");
			sb.append(" var xmlRef = this.parent.oXML;\n");
			sb.append(" exportData(xmlRef);\n");
			sb.append("}catch(e){\n");
			sb.append(" alert(\"ERROR: \"+ e);\n");
			sb.append("}\n");

			String[] saInclude = new String[]{"../common/scripts/emxUICore.js"};
			mpReturn.put(DCLConstants.ACTION_INCLUDEJAVASCRIPT, saInclude);
			mpReturn.put(DCLConstants.ACTION_JAVASCRIPT, sb.toString());
			return mpReturn;
		} catch (Exception e) {
			throw new DCLException(e);
		}
	}

	/**
	 * Access Function on Command Edit Details of Document
	 * Method is used to check Access For context user for not showing EditDetails
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return boolean status to show Edit Details Command
	 * @throws  DCLException if operation fails
	 */
	public boolean disableDocumentEdit(Context context, String[] args) throws DCLException{
		try{
			String policyName = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENTS);
			String strStateReleased = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName,
					DCLConstants.SYMBOLIC_STATE_RELEASED);
			String policyTemplateName = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENT_TEMPLATE);
			String strStateActive = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyTemplateName,
					DCLConstants.SYMBOLIC_STATE_ACTIVE);
			String strStateInactive = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyTemplateName,
					DCLConstants.SYMBOLIC_STATE_INACTIVE);
			String strRelTemplateToDoc = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_RELATIONSHIP_TEMPLATE_TO_DOCUMENT);
			boolean flag = true;
			String strLoginUser = context.getUser();
			PeriodicReviewService periodicReview = PeriodicReviewServiceUtil.getPeriodicReviewService(context);
			Map<?, ?> programMap = (Map) JPO.unpackArgs(args);
			String strDocId = (String)programMap.get(DCConstants.OBJECTID);
			DomainObject dObjDoc = DomainObject.newInstance(context, strDocId);
			String strDocOwner = DCLUtil.getInfo(context, strDocId, DomainConstants.SELECT_OWNER);
			StringList sSMEAssignmentRole = new StringList();
			sSMEAssignmentRole.add(DCLConstants.SMEROLE_ASSIGNED);
			sSMEAssignmentRole.add(DCLConstants.SMEROLE_TEMPORARY);
			StringList busSelects = new StringList();
			busSelects.add(DomainConstants.SELECT_NAME);
			List<Map> mlPerson = periodicReview.getPeriodicReviewRelatedData(context, strDocId, sSMEAssignmentRole,
					PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_Person), busSelects, null);
			String strPersonName = DomainConstants.EMPTY_STRING;
			if(!mlPerson.isEmpty())
			{
				Map mpPerson = mlPerson.get(0);
				strPersonName = (String) mpPerson.get(DomainConstants.SELECT_NAME);
				if(strLoginUser.equals(strPersonName) && !strLoginUser.equals(strDocOwner))
					flag = false;
			}
			String strState = DCLUtil.getInfo(context, strDocId, DomainConstants.SELECT_CURRENT);
			if (strState.equals(strStateActive) || strState.equals(strStateInactive)) {
				DomainObject dObj = DomainObject.newInstance(context, strDocId);
				String strDocumentIds = dObj.getInfo(context, "to["+strRelTemplateToDoc+"].id");
				if (UIUtil.isNotNullAndNotEmpty(strDocumentIds))
					flag = false;
				else
					flag = true;

			}
			if (strState.equals(strStateReleased)) {
				if (PersonUtil.hasAssignment(context,
						PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_DOCUMENT_CENTER_ADMINISTRATOR))
						||PersonUtil.hasAssignment(context,
								PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_VPLM_PROJECT_LEADER))
								|| strLoginUser.equals(strDocOwner))
					flag = true;
				else
					flag = false;

			}

			return flag;
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method is used to show Document Edit Details form
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return Map containing ACTION_JAVASCRIPT
	 * @throws  DCLException if operation fails
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> showDocumentEditView(Context context,String [] args) throws DCLException
	{
		try {
			boolean showTrainingEnabledEditable = false;
			String documentPolicyName = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENTS);
			String strStateReleased = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, documentPolicyName,
					DCLConstants.SYMBOLIC_STATE_RELEASED);
			String documentTemplatePolicyName = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENT_TEMPLATE);
			String strStateInactive = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, documentTemplatePolicyName,
					DCLConstants.SYMBOLIC_STATE_INACTIVE);
			String strTemplateToDocumentRel = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_RELATIONSHIP_TEMPLATE_TO_DOCUMENT);
			StringBuilder sbTemplateIdToDocument = new StringBuilder();
			sbTemplateIdToDocument.append("from[").append(strTemplateToDocumentRel).append("].to.id");
			String strLoginUser = context.getUser();
			PeriodicReviewService periodicReview = PeriodicReviewServiceUtil.getPeriodicReviewService(context);
			String flag = DomainConstants.EMPTY_STRING;
			Map<?, ?> programMap = (Map) JPO.unpackArgs(args);
			String tableRowId[] = (String[])programMap.get(DCLConstants.EMX_TABLE_ROW_ID);
			String strDocId[] = (String[])programMap.get(DCLConstants.OBJECTID);
			String isFromRMB[] = (String[])programMap.get("isFromRMB");
			StringList sSMEAssignmentRole = new StringList();
			sSMEAssignmentRole.add(DCLConstants.SMEROLE_OWNER);
			StringList slSelects = new StringList(3);
			slSelects.add(DomainConstants.SELECT_OWNER);
			slSelects.add(DomainConstants.SELECT_POLICY);
			slSelects.add(DomainConstants.SELECT_CURRENT);
			slSelects.add(sbTemplateIdToDocument.toString());
			String strDocTemplatePolicy = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENT_TEMPLATE); 
			StringList busSelects = new StringList();
			busSelects.add(DomainConstants.SELECT_NAME);

			if(!DCLUtil.isNullOrEmpty(tableRowId)){
				for(String strRowIds:tableRowId)
				{
					String strRowId=strRowIds;
					TableRowId tableRowID=new TableRowId(strRowId);
					strDocId[0] = tableRowID.getObjectId();
				}
			}

			Map mDocInfo = DCLUtil.getInfo(context, strDocId[0], slSelects);
			String strDocOwner = (String)mDocInfo.get(DomainConstants.SELECT_OWNER);
			String strPolicy = (String)mDocInfo.get(DomainConstants.SELECT_POLICY);
			String strCurrent = (String) mDocInfo.get(DomainConstants.SELECT_CURRENT);
			String strConnectedTemplateId = (String) mDocInfo.get(sbTemplateIdToDocument.toString());

			List<Map> mlPerson = periodicReview.getPeriodicReviewRelatedData(context, strDocId[0], sSMEAssignmentRole,
					PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_Person), busSelects, null);
			if (!mlPerson.isEmpty()) {
				Map mpPerson = mlPerson.get(0);
				String strSMEOwnerName = (String) mpPerson.get(DomainConstants.SELECT_NAME);
				if(strLoginUser.equals(strSMEOwnerName) && !(strDocOwner.equals(strSMEOwnerName) || PersonUtil.hasAssignment(context,
						PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_DOCUMENT_CENTER_ADMINISTRATOR))|| PersonUtil.hasAssignment(context,
								PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_VPLM_PROJECT_LEADER))|| PersonUtil.hasAssignment(context,
										PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_3DSRestrictedLeader)))) {
					flag = "showSMEOnly";  
				}  
			}           
			if (strCurrent.equals(strStateReleased)
					&& (strLoginUser.equals(strDocOwner) || PersonUtil.hasAssignment(context,
							PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_DOCUMENT_CENTER_ADMINISTRATOR))|| PersonUtil.hasAssignment(context,
									PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_VPLM_PROJECT_LEADER))))
				flag = "editSME";

			if(documentTemplatePolicyName.equals(strPolicy) && strStateInactive.equals(strCurrent))
				showTrainingEnabledEditable = true;
			else if(documentPolicyName.equals(strPolicy) && UIUtil.isNullOrEmpty(strConnectedTemplateId))
				showTrainingEnabledEditable = true;

			Map<String, String> mReturnMap  = new HashMap<String, String>();

			if(null != isFromRMB){
				DCLUtil.encodeFunctionForJavaScript(context, false, "showDocumentEditView", strDocId[0],
						flag, strDocTemplatePolicy, strPolicy,isFromRMB[0]);
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "showDocumentEditView('"+strDocId[0]+"','"+flag+"', '"+strDocTemplatePolicy+"', '"+strPolicy+"','"+isFromRMB[0]+"','"+showTrainingEnabledEditable+"')");
			}
			else
			{
				DCLUtil.encodeFunctionForJavaScript(context, false, "showDocumentEditView", strDocId[0],
						flag, strDocTemplatePolicy, strPolicy,"");
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "showDocumentEditView('"+strDocId[0]+"','"+flag+"', '"+strDocTemplatePolicy+"', '"+strPolicy+"','"+DomainConstants.EMPTY_STRING+"','"+showTrainingEnabledEditable+"')");
			}
			return mReturnMap;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method to get All Revisions of Document
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return MapList of Document revisions
	 * @throws  DCLException if operation fails
	 */
	@com.matrixone.apps.framework.ui.ProgramCallable
	public List<Map> getDocumentAllRevisions(Context context, String[] args) throws DCLException
	{
		try {
			Map<?,?> programMap = (Map<?,?>)JPO.unpackArgs(args);
			String strObjectId= (String) programMap.get(DCConstants.OBJECTID);
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			List<Map> mlDocuments=documentService.getAllDocumentRevisions(context,strObjectId);
			return mlDocuments;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}


	/**
	 * Returns list containing HTML link for organization
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds object list
	 * @return List containing HTML link for organization
	 * @throws DCLException if operation fails
	 */
	public Vector<String> getOrganizationLinks(Context context, String[] args) 
			throws DCLException 
			{
		try {
			Map programMap = (Map) JPO.unpackArgs(args);
			MapList mlObjectList = (MapList) programMap.get(DCConstants.OBJECTLIST);
			Map paramList = (Map) programMap.get(DCConstants.PARAMLIST);
			String strReportFormat = (String) paramList.get(DCConstants.REPORTFORMAT);
			Vector<String> lLinks = new Vector<String>();
			// Getting the bus ids for objects in the table
			List<String> slObjectid=new StringList();

			String strTypeOrganization = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_Organization);
			Map mOrgIds=DCLUtil.getTypeObjectIds(context, strTypeOrganization);

			for (Object object : mlObjectList) {
				Map map = (Map) object;
				String strOrgName = (String) (map.get(DomainConstants.SELECT_ORGANIZATION));
				if(UIUtil.isNullOrEmpty(strOrgName)){
					String strId = (String) map.get(DomainConstants.SELECT_ID);
					if(UIUtil.isNotNullAndNotEmpty(strId)){
						DomainObject domObj = DomainObject.newInstance(context, strId);
						//strOrgName = domObj.getInfo(context, DomainConstants.SELECT_ORGANIZATION);
					}
					if(UIUtil.isNullOrEmpty(strOrgName)){
						strOrgName = DomainConstants.EMPTY_STRING;
					}
				}
				if (UIUtil.isNullOrEmpty(strReportFormat) && UIUtil.isNotNullAndNotEmpty(strOrgName)) {
					String strOrgId = (String) mOrgIds.get(strOrgName);
					strOrgName = DCUtil.getObjectLink(context, strOrgId, strOrgName);
				}
				lLinks.add(strOrgName);
			}
			return lLinks;
		} catch (Exception ex) {
			throw new DCLException(ex.getMessage());
		}
			}

	/**
	 * Method to Exclude Change Orders and Change Request where context user do not have modify access
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return List<String> of Change Orders
	 * @throws  DCLException if operation fails
	 */
	@com.matrixone.apps.framework.ui.ExcludeOIDProgramCallable
	public List<String> excludeNoModifyAccessChangeOrder(Context context,String []args) throws DCLException
	{
		try {
			Map programMap = JPO.unpackArgs(args);
			String strChange = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_ORDER);
			String strAddChange = (String) programMap.get("addChange");
			List<String> slExcludeCOList = new StringList();
			StringList slObjectSelect = new StringList();
			slObjectSelect.add(DomainConstants.SELECT_ID);
			if(strAddChange.equals("CR"))
				strChange = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_REQUEST);
			List<Map> mlChange = DCLUtil.getObjects(context, strChange,"*", null, slObjectSelect);
			for(Map<String,String> mpChange : mlChange)
			{
				String strChangeId = mpChange.get(DomainConstants.SELECT_ID);
				DomainObject dObDocId=DomainObject.newInstance(context,strChangeId);
				Boolean bAccess=dObDocId.checkAccess(context, (short) AccessConstants.cModify);
				if(!bAccess)
				{
					slExcludeCOList.add(strChangeId);
				}
			}
			return slExcludeCOList;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method to Add Existing Change Order to Selected Controlled Documents Objects
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return Map containing ACTION_JAVASCRIPT
	 * @throws  DCLException if operation fails
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> getExistingChangeOrdersPreProcess(Context context,String [] args) throws Exception
	{
		String strJavascript = DomainConstants.EMPTY_STRING;
		ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
		String policyName = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENTS );
		String strAlertMsg = "enoDocumentControl.Alert.AddChangeOrder";
		String strPreliminaryState = PropertyUtil.getSchemaProperty(context,DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_PRELIMINARY);
		String strReleasedState = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_RELEASED);
		String strSupersededState = PropertyUtil.getSchemaProperty(context,DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_SUPERSEDED);
		Map prograMap = JPO.unpackArgs(args);
		String tableRowId[] = (String[])prograMap.get(DCLConstants.EMX_TABLE_ROW_ID);
		String strAddChange[] = (String[]) prograMap.get("addChange");
		Map mpDocuments = documentService.getValidAndInvalidDocumentsForAddingChangeOrder(context,tableRowId);
		String strDocIds = (String) mpDocuments.get("ValidDocList");
		MapList mlInvalidDocIds =  (MapList) mpDocuments.get("InvalidDocList");
		List<String> slInvalidDocument = getErrorMessage(context, mlInvalidDocIds);
		Map<String, String> mReturnMap  = new HashMap<String, String>();
		StringBuilder sbURL=new StringBuilder();
		String strInvalidDocumentMessage = DomainConstants.EMPTY_STRING;

		if (slInvalidDocument.size() > 0) {
			if (!DCLUtil.isNullOrEmpty(strAddChange) && strAddChange[0].equals("CR")) {
				strAlertMsg = "enoDocumentControl.Alert.AddChangeRequest";
				strInvalidDocumentMessage = MessageUtil.getMessage(context, null, strAlertMsg, new String[] { slInvalidDocument.toString(),
						PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_PRELIMINARY),
						PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_RELEASED),
						PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_SUPERSEDED) },
						null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				DCLUtil.encodeFunctionForJavaScript(context, false, "getExistingChangeOrdersPreProcess", strInvalidDocumentMessage,strAddChange[0],DomainConstants.EMPTY_STRING);
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "getExistingChangeOrdersPreProcess('"+strInvalidDocumentMessage+"','"+strAddChange[0]+"','"+DomainConstants.EMPTY_STRING+"')");
			}
			else if (!DCLUtil.isNullOrEmpty(strAddChange) && strAddChange[0].equals("CA")) {

				strAlertMsg = "enoDocumentControl.Alert.AddChangeAction";
				strInvalidDocumentMessage = MessageUtil.getMessage(context, null, strAlertMsg, new String[] { slInvalidDocument.toString(),
						PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_PRELIMINARY),
						PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_RELEASED),
						PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_SUPERSEDED) },
						null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				DCLUtil.encodeFunctionForJavaScript(context, false, "getExistingChangeOrdersPreProcess", strInvalidDocumentMessage,strAddChange[0],DomainConstants.EMPTY_STRING);
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "getExistingChangeOrdersPreProcess('"+strInvalidDocumentMessage+"','"+strAddChange[0]+"','"+DomainConstants.EMPTY_STRING+"')");
			}
			else
			{
				strInvalidDocumentMessage = MessageUtil.getMessage(context, null, strAlertMsg, new String[] { slInvalidDocument.toString(),
						PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_PRELIMINARY),
						PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_RELEASED),
						PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName, DCLConstants.SYMBOLIC_STATE_SUPERSEDED) },
						null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				DCLUtil.encodeFunctionForJavaScript(context, false, "getExistingChangeOrdersPreProcess", strInvalidDocumentMessage,DomainConstants.EMPTY_STRING,DomainConstants.EMPTY_STRING);
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "getExistingChangeOrdersPreProcess('"+strInvalidDocumentMessage+"','"+DomainConstants.EMPTY_STRING+"','"+DomainConstants.EMPTY_STRING+"')");
			}

		}
		else {
			if(!DCLUtil.isNullOrEmpty(strAddChange) && strAddChange[0].equals("CR")){
				DCLUtil.encodeFunctionForJavaScript(context, false, "getExistingChangeOrdersPreProcess",strInvalidDocumentMessage,strAddChange[0],strDocIds);	
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "getExistingChangeOrdersPreProcess('"+strInvalidDocumentMessage+"','"+strAddChange[0]+"','"+strDocIds+"')");
			}
			else if(!DCLUtil.isNullOrEmpty(strAddChange) && strAddChange[0].equals("CA")){

				DCLUtil.encodeFunctionForJavaScript(context, false, "getExistingChangeOrdersPreProcess",strInvalidDocumentMessage,strAddChange[0],strDocIds);	
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "getExistingChangeOrdersPreProcess('"+strInvalidDocumentMessage+"','"+strAddChange[0]+"','"+strDocIds+"')");
			}
			else{
				DCLUtil.encodeFunctionForJavaScript(context, false, "getExistingChangeOrdersPreProcess",strInvalidDocumentMessage,DomainConstants.EMPTY_STRING,strDocIds);
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "getExistingChangeOrdersPreProcess('"+strInvalidDocumentMessage+"','"+DomainConstants.EMPTY_STRING+"','"+strDocIds+"')");
			}
		}
		return mReturnMap;
	}

	/**
	 * Method to connect Affected Items to Existing Change Order
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @throws  DCLException if operation fails
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> connectExistingChangeOrderToDocument(Context context,String [] args) throws DCLException
	{
		try {
			ContextUtil.startTransaction(context,true);
			ChangeManagement change = new ChangeManagement();
			Map<String,String> mReturnMap = new HashMap();
			String strObjectId = DomainConstants.EMPTY_STRING;
			String strChangeAlertMsg = "enoDocumentControl.Alert.Msg.ExistingCOAdd";
			Map<?,?> programMap = (Map)JPO.unpackArgs(args);
			StringList slDocId = new StringList();
			StringList slObjectSelects = new StringList();
			StringBuilder sb = new StringBuilder();
			slObjectSelects.add(DomainObject.SELECT_NAME);
			slObjectSelects.add(DomainObject.SELECT_TYPE);
			slObjectSelects.add(DomainObject.SELECT_REVISION);
			String strAddChange[] = (String[]) programMap.get("addChange");
			String arrTableRowId[] = (String[])programMap.get(DCLConstants.TABLEROWID);
			String strTableRowId = arrTableRowId[0];
			TableRowId tableRowId=new TableRowId(strTableRowId);
			String strChangeId = tableRowId.getObjectId();
			String strIsOneSearchEnabled = DCLConstants.TRUE;
			try{
				strIsOneSearchEnabled =	EnoviaResourceBundle.getProperty(context, DCLConstants.SEARCH_MODE);
			}
			catch(Exception e){}

			if(!DCLUtil.isNullOrEmpty(strAddChange) && strAddChange[0].equals("CR")){
				change = new ChangeRequest(strChangeId);
				strChangeAlertMsg = "enoDocumentControl.Alert.Msg.ExistingCRAdd";
			}
			else if(!DCLUtil.isNullOrEmpty(strAddChange) && strAddChange[0].equals("CA")){
				change = new ChangeAction(strChangeId);
				strChangeAlertMsg = "enoDocumentControl.Alert.Msg.ExistingCAAdd";
			}
			else
				change = new ChangeOrder(strChangeId);

			Map map = DCLUtil.getInfo(context, strChangeId, slObjectSelects);
			String strType = EnoviaResourceBundle.getProperty(context, "emxFrameworkStringResource", context.getLocale(), "emxFramework.Type."
					+ ((String) map.get(DomainConstants.SELECT_TYPE)).replace(" ", "_"));

			String arrObjectId[] = (String[])programMap.get(DCConstants.OBJECTID);
			if (arrObjectId != null) {
				strObjectId = arrObjectId[0];
				slDocId.add(strObjectId);
				change.connectAffectedItems(context,slDocId);
				ContextUtil.commitTransaction(context);

				String strMessage = MessageUtil.getMessage(context, null, strChangeAlertMsg,
						new String[] {strType,(String) map.get(DomainConstants.SELECT_NAME),(String) map.get(DomainConstants.SELECT_REVISION)},
						null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				DCLUtil.encodeFunctionForJavaScript(context, false, "connectExistingChangeOrderToDocument",strMessage,arrObjectId[0]);
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "connectExistingChangeOrderToDocument('"+strMessage+"','"+arrObjectId[0]+"','"+strIsOneSearchEnabled+"')");
			}
			else
			{
				String [] arrDocIDs = (String[]) programMap.get("appendedDocIds");
				String strDocIds = arrDocIDs[0];
				slDocId = FrameworkUtil.split(strDocIds, DCLConstants.COMMA);
				change.connectAffectedItems(context,slDocId);
				ContextUtil.commitTransaction(context);
				String strMessage = MessageUtil.getMessage(context, null, strChangeAlertMsg,
						new String[] {strType,(String) map.get(DomainConstants.SELECT_NAME),(String) map.get(DomainConstants.SELECT_REVISION)},
						null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				DCLUtil.encodeFunctionForJavaScript(context, false, "connectExistingChangeOrderToDocument",strMessage,"");
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "connectExistingChangeOrderToDocument('"+strMessage+"',\"\""+",'"+strIsOneSearchEnabled+"')");

			}

			return mReturnMap;
		} catch (Exception e) {
			ContextUtil.abortTransaction(context);
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method to Add New Change Order to selected Controlled Documents Objects
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return Map containing ACTION_JAVASCRIPT
	 * @throws DCLException if operation fails
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> preProcessAddChangeOrder(Context context,String [] args) throws DCLException
	{
		try {
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			String policyName = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENTS );
			String strErrorType = "enoDocumentControl.Alert.AddChangeOrder";
			Map prograMap = JPO.unpackArgs(args);
			String tableRowId[] = (String[])prograMap.get(DCLConstants.EMX_TABLE_ROW_ID);

			//extra parameter added to differentiate if object to be created is CO or CR 
			String strCreateObjectType[] = (String[]) prograMap.get("createObj");

			Map mpDocuments = documentService.getValidAndInvalidDocumentsForAddingChangeOrder(context,tableRowId);
			String strDocIds = (String) mpDocuments.get("ValidDocList");
			MapList mlInvalidDocIds =  (MapList) mpDocuments.get("InvalidDocList");
			Map<String, String> mReturnMap  = new HashMap<String, String>();
			StringBuilder sbURL=new StringBuilder();
			String strInvalidDocumentMessage = DomainConstants.EMPTY_STRING;
			if (null != mlInvalidDocIds && !mlInvalidDocIds.isEmpty()) {
				List<String> slInvalidDocument = getErrorMessage(context, mlInvalidDocIds);
				if (slInvalidDocument.size() > 0) {
					if(!DCLUtil.isNullOrEmpty(strCreateObjectType) && (strCreateObjectType[0].equals("CR") || strCreateObjectType[0].equals("CA"))){
						if(strCreateObjectType[0].equals("CR"))
							strErrorType = "enoDocumentControl.Alert.AddChangeRequest";
						if(strCreateObjectType[0].equals("CA"))
							strErrorType = "enoDocumentControl.Alert.AddChangeAction";

						strInvalidDocumentMessage = MessageUtil.getMessage(
								context,
								null,
								strErrorType,
								new String[] {
										slInvalidDocument.toString(),
										PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName,
												DCLConstants.SYMBOLIC_STATE_PRELIMINARY),
												PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName,
														DCLConstants.SYMBOLIC_STATE_RELEASED),
														PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName,
																DCLConstants.SYMBOLIC_STATE_SUPERSEDED) }, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
						DCLUtil.encodeFunctionForJavaScript(context, false, "preProcessAddChangeOrder",strInvalidDocumentMessage,strCreateObjectType[0],DomainConstants.EMPTY_STRING);
						mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "preProcessAddChangeOrder('"+strInvalidDocumentMessage+"','"+strCreateObjectType[0]+"','"+DomainConstants.EMPTY_STRING+"')");
					}
					else
					{

						strInvalidDocumentMessage = MessageUtil.getMessage(
								context,
								null,
								strErrorType,
								new String[] {
										slInvalidDocument.toString(),
										PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName,
												DCLConstants.SYMBOLIC_STATE_PRELIMINARY),
												PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName,
														DCLConstants.SYMBOLIC_STATE_RELEASED),
														PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName,
																DCLConstants.SYMBOLIC_STATE_SUPERSEDED) }, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
						DCLUtil.encodeFunctionForJavaScript(context, false, "preProcessAddChangeOrder",strInvalidDocumentMessage,DomainConstants.EMPTY_STRING,DomainConstants.EMPTY_STRING);
						mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "preProcessAddChangeOrder('"+strInvalidDocumentMessage+"','"+DomainConstants.EMPTY_STRING+"','"+DomainConstants.EMPTY_STRING+"')");
					}
				}
			}
			else {
				if(!DCLUtil.isNullOrEmpty(strCreateObjectType) &&(strCreateObjectType[0].equals("CR") || strCreateObjectType[0].equals("CA") )){					DCLUtil.encodeFunctionForJavaScript(context, false, "preProcessAddChangeOrder",strInvalidDocumentMessage,strCreateObjectType[0],strDocIds);	
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "preProcessAddChangeOrder('"+strInvalidDocumentMessage+"','"+strCreateObjectType[0]+"','"+strDocIds+"')");
				}
				else{
					DCLUtil.encodeFunctionForJavaScript(context, false, "preProcessAddChangeOrder",strInvalidDocumentMessage,DomainConstants.EMPTY_STRING,strDocIds);
					mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "preProcessAddChangeOrder('"+strInvalidDocumentMessage+"','"+DomainConstants.EMPTY_STRING+"','"+strDocIds+"')");
				}
			}
			return mReturnMap;
		}
		catch (FrameworkException e) {
			throw new DCLException(e.getMessage());
		}
		catch (Exception e) {
			throw new DCLException(e.getMessage());
		}
	}

	/**
	 * Method to connect Affected Items to Change Order
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @throws  DCLException if operation fails
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map connectChangeOrderToDocument(Context context,String [] args) throws DCLException
	{
		try {
			ChangeManagement change = new ChangeManagement();
			Map programMap = JPO.unpackArgs(args);
			String strCreateAlert = "enoDocumentControl.Alert.Msg.SuccessfullCreateCO";
			StringList slSelectedDocumentIds = new StringList();
			StringList slObjectSelects = new StringList();
			slObjectSelects.add(DomainObject.SELECT_NAME);
			slObjectSelects.add(DomainObject.SELECT_TYPE);
			slObjectSelects.add(DomainObject.SELECT_REVISION);
			StringBuilder sb = new StringBuilder();
			Map mReturnMap = new HashMap<>();
			String[] strSelectedDocumentIds = (String[]) programMap.get(DCLConstants.EMX_TABLE_ROW_ID);

			// extra parameter added to differentiate if object to be created is
			// CO or CR
			String strCreateObjectType[] = (String[]) programMap.get("createObj");

			String strCOId = ((String[]) programMap.get(DCLConstants.NEW_OBJECTID))[0];
			Map map = DCLUtil.getInfo(context, strCOId, slObjectSelects);
			if(!DCLUtil.isNullOrEmpty(strCreateObjectType) && strCreateObjectType[0].equals("CR")){
				change = new ChangeRequest(strCOId);
				strCreateAlert = "enoDocumentControl.Alert.Msg.SuccessfullCreateCR";
			}
			else if(!DCLUtil.isNullOrEmpty(strCreateObjectType) && strCreateObjectType[0].equals("CA")){
				change = new ChangeAction(strCOId);
				strCreateAlert = "enoDocumentControl.Alert.Msg.SuccessfullCreateCA";

			}
			else{
				change = new ChangeOrder(strCOId);
			}

			String strType = EnoviaResourceBundle.getProperty(context, "emxFrameworkStringResource", context.getLocale(), "emxFramework.Type."
					+ ((String) map.get(DomainConstants.SELECT_TYPE)).replace(" ", "_"));
			if (DCLUtil.isNullOrEmpty(strSelectedDocumentIds)) {
				String[] strobjid = (String[]) programMap.get(DCLConstants.OBJECTID);	
				slSelectedDocumentIds.add(strobjid[0]);
				change.connectAffectedItems(context,slSelectedDocumentIds);

				String strMessage = MessageUtil.getMessage(context, null, strCreateAlert,
						new String[] {strType,(String) map.get(DomainConstants.SELECT_NAME),(String) map.get(DomainConstants.SELECT_REVISION)},
						null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				DCLUtil.encodeFunctionForJavaScript(context, false, "connectChangeOrderToDocument",strMessage,"");
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "connectChangeOrderToDocument('"+strMessage+"',\"\")");
			}
			else {
				if (strSelectedDocumentIds[0].indexOf(DCLConstants.COMMA) > -1) {
					slSelectedDocumentIds = FrameworkUtil.split(strSelectedDocumentIds[0], DCLConstants.COMMA);
				}
				else {
					slSelectedDocumentIds.add(strSelectedDocumentIds[0]);
				}
				change.connectAffectedItems(context,slSelectedDocumentIds);

				String strMessage = MessageUtil.getMessage(context, null, strCreateAlert,
						new String[] {strType,(String) map.get(DomainConstants.SELECT_NAME),(String) map.get(DomainConstants.SELECT_REVISION)},
						null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				DCLUtil.encodeFunctionForJavaScript(context, false, "connectChangeOrderToDocument",strMessage,strSelectedDocumentIds[0]);
				mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "connectChangeOrderToDocument('"+strMessage+"','"+strSelectedDocumentIds[0]+"')");
			}
			return mReturnMap;
		}
		catch (Exception e) {
			throw new DCLException(e.getMessage());
		}

	}

	/**
	 * Access Program to hide the CO column in Document Template global search
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @throws  DCLException if operation fails
	 */
	public boolean isNotForTemplates(Context context, String[] args) throws DCLException{
		boolean bReturn = true;
		try{
			Map<?, ?> programMap = (Map) JPO.unpackArgs(args);
			String strPolicy = (String)programMap.get("field_actual");
			strPolicy = strPolicy.substring(strPolicy.indexOf("POLICY=")+7, strPolicy.length());
			if(DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENT_TEMPLATE.equals(strPolicy)){
				bReturn = false;
			}
		} catch (Exception e) {
			throw new DCLException(e.getMessage());
		}
		return bReturn;
	}

	public String showFileSizeOnFilePropertiesPage(Context context,String args[]) throws Exception
	{
		try{
			int index =0;
			String Name =new String();
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			HashMap programMap = JPO.unpackArgs(args);
			Map requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			String fileObjectId = (String) requestMap.get(DCLConstants.OBJECTID);

			Map mapName = documentService.getFileData(context, fileObjectId);
			StringList slName = (StringList) mapName.get(CommonDocument.SELECT_FILE_NAME);
			StringList slSize = (StringList) mapName.get(CommonDocument.SELECT_FILE_SIZE);
			StringList slFormat = (StringList) mapName.get(CommonDocument.SELECT_FILE_FORMAT);
			String strName = (String) mapName.get(DomainConstants.SELECT_NAME);
			if (null != slName) {
				for (Object obj : slName) {
					if(strName.equals(obj))
						index = slName.indexOf(strName);
				}
			}
			return (String) slSize.get(index);
		}
		catch(Exception e)
		{
			throw new DCLException(e.getMessage());
		}	
	}


	public String showFileFormatOnFilePropertiesPage(Context context,String args[]) throws DCLException
	{
		try{
			int index =0;
			String Name =new String();
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			HashMap programMap = JPO.unpackArgs(args);
			Map requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			String fileObjectId = (String) requestMap.get(DCLConstants.OBJECTID);

			Map mapName = documentService.getFileData(context, fileObjectId);
			StringList slName = (StringList) mapName.get(CommonDocument.SELECT_FILE_NAME);
			StringList slSize = (StringList) mapName.get(CommonDocument.SELECT_FILE_SIZE);
			StringList slFormat = (StringList) mapName.get(CommonDocument.SELECT_FILE_FORMAT);
			String strName = (String) mapName.get(DomainConstants.SELECT_NAME);
			if (null != slName) {
				for (Object obj : slName) {
					if(strName.equals(obj))
						index = slName.indexOf(strName);
				}
			}
			return (String) slFormat.get(index);
		}
		catch(Exception e)
		{
			throw new DCLException(e.getMessage());
		}	
	}

	public String getCreateDocumentScript(Context context,String[] args) throws Exception {
		return "<script>\n"
				+ "var templateDisplay = document.getElementsByName('TemplateDisplay');\n"
				+ "templateDisplay[0].disabled = true;\n"
				+ "var vTemplateChooser = document.getElementsByName('btnTemplate');\n"
				+ "var objForm = document.forms[0];\n"
				+ "var selectedType =null;\n"
				+ "selectedType = objForm.elements[\"TypeActual\"].value;\n"
				+

				"selectedType = ReplaceAll(selectedType,\" \",\"\"); \n"
				+ "vTemplateChooser[0].onclick = function () { javascript:showChooser('../common/emxFullSearch.jsp?field=TYPE=type_'+selectedType+':CURRENT=policy_ControlledDocumentTemplate.state_Active&amp;fieldNameOID=TemplateOID&amp;form=DCLDocumentsSearchFilters&amp;massPromoteDemote=false&amp;suiteKey=DocumentControl&amp;submitURL=../documentcontrol/enoDCLExecute.jsp?dclAction=ENODCLTemplateAttributesGroupingUI:getSelectedTemplateInterface&amp;table=DCLDocumentsSearch&amp;fieldNameDisplay=TemplateDisplay&amp;fieldNameActual=Template&amp;submitAction=refreshCaller&amp;selection=single&amp;formInclusionList=DCL_DOC_RO','600','600','true','','Template') } \n"
				+ "var vTemplate = document.getElementById('calc_Template');\n" +

				"var vFirstField = vTemplate.parentNode.firstChild;\n" + "var c1 = vTemplate.cloneNode(true);\n" + "try {\n"
				+ "vTemplate.parentNode.insertBefore(vTemplate, vFirstField.nextElementSibling);\n" + "} catch(e) {\n" + "alert('ERR');\n" + "}\n"
				+ "" + "</script>";
		//return DCLUtil.encodeFunctionForJavaScript(context, false, "getCreateDocumentScript");
	}

	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map getTemplateDetails(Context context,String[] args) throws DCLException 
	{ 
		String strTypePerson = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_Person);
		String strTypeMemberList = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_MemberList);

		try {
			Map<String,String> mpReturn = new HashMap<String,String> ();
			Map hmParamMap = (Map) JPO.unpackArgs(args);
			String[] strTemplate = (String[]) hmParamMap.get("templateOID");
			String strTemplateOID = strTemplate[0];
			String strTitle = DomainConstants.EMPTY_STRING;
			String strDescription =DomainConstants.EMPTY_STRING;
			String strOrg = DomainConstants.EMPTY_STRING;
			String strOrgId = DomainConstants.EMPTY_STRING;
			String strPRI = DomainConstants.EMPTY_STRING;
			String strPRE = DomainConstants.EMPTY_STRING;
			String strDocCategory=DomainConstants.EMPTY_STRING;
			String strDocAutoNaming=DomainConstants.EMPTY_STRING;
			String strSMEName=DomainConstants.EMPTY_STRING;
			String strSMEId=DomainConstants.EMPTY_STRING;
			String strDocType=DomainConstants.EMPTY_STRING;
			String strTrainingEnabled = "Yes";
			Boolean boolCheckinFile = Boolean.TRUE;
			StringBuilder sbRelSelect = new StringBuilder("relationship[").append(
					PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_RELATIONSHIP_ACTIVE_VERSION)).append("]");

			if(UIUtil.isNotNullAndNotEmpty(strTemplateOID))
			{
				String strPeriodicReviewEnabled=PropertyUtil.getSchemaProperty(context,DCLConstants.SYMBOLIC_ATTRIBUTE_PERIODIC_REVIEW_ENABLED);
				String strPeriodicReviewInterval=PropertyUtil.getSchemaProperty(context,DCLConstants.SYMBOLIC_ATTRIBUTE_PERIODIC_REVIEW_INTERVAL);
				String strAttrDocumentCategory=PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_QUALITY_SYSTEM_DOCUMENT_CATEGORY);
				String strTrainingEnabledAttribute=PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_TRAINING_ENABLED);
				String strDocumentAutonaming=PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_DOCUMENT_AUTONAMING);
				StringList slSelect=new StringList();

				slSelect.add("attribute["+DomainConstants.ATTRIBUTE_TITLE+"]");
				slSelect.add(DomainConstants.SELECT_DESCRIPTION);
				slSelect.add(DomainConstants.SELECT_ORGANIZATION);
				slSelect.add(DomainObject.getAttributeSelect(strPeriodicReviewEnabled));
				slSelect.add(DomainObject.getAttributeSelect(strPeriodicReviewInterval));

				slSelect.add(DomainObject.getAttributeSelect(strAttrDocumentCategory));
				slSelect.add(sbRelSelect.toString());

				slSelect.add(DomainObject.getAttributeSelect(strTrainingEnabledAttribute));
				slSelect.add(DomainObject.getAttributeSelect(strDocumentAutonaming));
				slSelect.add(DomainObject.SELECT_TYPE);	

				Map<String,String> mTempInfo = DCLUtil.getInfo(context, strTemplateOID, slSelect);

				strTitle=mTempInfo.get("attribute["+DomainConstants.ATTRIBUTE_TITLE+"]");
				strDescription=mTempInfo.get(DomainConstants.SELECT_DESCRIPTION);

				strOrg=mTempInfo.get(DomainConstants.SELECT_ORGANIZATION);
				strOrgId=DCLUtil.getOrganizationId(context,strOrg);

				strPRI=mTempInfo.get(DomainObject.getAttributeSelect(strPeriodicReviewInterval));
				strPRE=mTempInfo.get(DomainObject.getAttributeSelect(strPeriodicReviewEnabled));
				strDocCategory=mTempInfo.get(DomainObject.getAttributeSelect(strAttrDocumentCategory));
				strDocAutoNaming=mTempInfo.get(DomainObject.getAttributeSelect(strDocumentAutonaming));
				strTrainingEnabled = mTempInfo.get(DomainObject.getAttributeSelect(strTrainingEnabledAttribute));


				strDocType=mTempInfo.get(DomainObject.SELECT_TYPE);

				slSelect=new StringList();
				slSelect.add(DomainConstants.SELECT_ID);
				slSelect.add(DomainConstants.SELECT_NAME);
				slSelect.add(DomainConstants.SELECT_TYPE);

				List slRoles=new StringList();
				slRoles.add(PeriodicReviewConstants.SMEROLE_OWNER);
				slRoles.add(PeriodicReviewConstants.SMEROLE_TEMPORARY);

				PeriodicReviewService periodicReview=PeriodicReviewServiceUtil.getPeriodicReviewService(context);
				List<Map> mlSME=periodicReview.getPeriodicReviewRelatedData(context, strTemplateOID, slRoles, strTypeMemberList+","+strTypePerson, (List)slSelect, "");
				Iterator itr=mlSME.iterator();

				while(itr.hasNext())
				{
					Map mpSME=(Map)itr.next();
					if(strTypeMemberList.equals(mpSME.get(DomainConstants.SELECT_TYPE)))
					{
						strSMEName=(String)mpSME.get(DomainConstants.SELECT_NAME);
						strSMEId=(String)mpSME.get(DomainConstants.SELECT_ID);
						break;
					}
					else
					{
						strSMEName=(String)mpSME.get(DomainConstants.SELECT_NAME);
						strSMEId=(String)mpSME.get(DomainConstants.SELECT_ID);
					}
				}

				if (DCLConstants.FALSE.equalsIgnoreCase(mTempInfo.get(sbRelSelect.toString())))
					boolCheckinFile = Boolean.TRUE;
				else
					boolCheckinFile = Boolean.FALSE;
			}


			StringBuffer sBuff= new StringBuffer();
			sBuff.append(strTitle).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strDescription).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strOrg).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strOrgId).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strPRI).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strPRE).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strDocCategory).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(boolCheckinFile).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strSMEName).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strSMEId).append(DCLConstants.PIPE_SEPARATOR);

			sBuff.append(strTrainingEnabled).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strDocAutoNaming).append(DCLConstants.PIPE_SEPARATOR);
			sBuff.append(strDocType).append(DCLConstants.PIPE_SEPARATOR);
			mpReturn.put(DCLConstants.ACTION_AJAX, sBuff.toString());
			return mpReturn;
		} catch (Exception e) {
			throw new DCLException();
		}
	}
	/**
	 * Access program for Template field on create Document/Document Template page
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments.
	 * @return boolean status to show "Template" Field.
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public boolean showTemplateField(Context context,String[] args) throws DCLException {
		boolean isDisplay = false;
		try { 
			List<String> slPolicies = new StringList();
			Map<?,?> hmParamMap = (Map<?,?>) JPO.unpackArgs(args); 
			String strDCmode = (String) hmParamMap.get(DCConstants.DCMODE);
			String strType = (String) hmParamMap.get(DomainConstants.SELECT_TYPE);
			String strSelType = DCLUtil.getTypeAfterSplit(context,strType);
			if(DCLConstants.CREATEDOCUMENT.equals((strDCmode))) {
				isDisplay = true;
			} 
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		} 
		return isDisplay;
	}

	/**
	 * This method will be called to get all "CONTROLLEDDOCUMENTS" which are not
	 * released and ( for which user is assigned as Subject Matter Expert OR
	 * "CONTROLLEDDOCUMENTS" from organization where user is assigned as
	 * Administrator)
	 * 
	 * @param context
	 *            the ENOVIA <code>Context</code> object
	 * @param args
	 *            holds no value
	 * @return MapList containing Document details
	 * @throws Exception if the operation fails
	 * @exclude
	 */
	public List<Map> getActiveDocuments(Context context, String args[]) throws FrameworkException {
		return getFilterDocuments(context, DCLConstants.ACTIVE);
	}
	/**
	 * This method will be called to get all "CONTROLLEDDOCUMENTS" in any state
	 * 
	 * @param context
	 *            the ENOVIA <code>Context</code> object
	 * @param args
	 *            holds no value
	 * @return MapList containing Document details
	 * @throws Exception
	 *             if the operation fails
	 * @exclude
	 */
	@com.matrixone.apps.framework.ui.ProgramCallable
	public List<Map> getAllDocuments(Context context, String args[]) throws FrameworkException {
		try{
			Map programMap=(Map) JPO.unpackArgs(args);
			String filter = (String) programMap.get("DCLDocumentFilter");
			return getFilterDocuments(context, filter);
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * This method will be called to get all "CONTROLLEDDOCUMENTS" which are
	 * released and ( for which user is assigned as Subject Matter Expert OR
	 * "CONTROLLEDDOCUMENTS" from organization where user is assigned as
	 * Administrator )
	 * 
	 * @param context
	 *            the ENOVIA <code>Context</code> object
	 * @param args
	 *            holds no value
	 * @return MapList containing Document details
	 * @throws Exception if the operation fails
	 * @exclude
	 */
	public List<Map> getReleasedDocuments(Context context, String args[]) throws DCLException {
		return getFilterDocuments(context, DCLConstants.RELEASED);
	}

	private List<Map> getChildOrganization(Context context ,String strOrganizationId,String strWhere) throws DCLException{

		try {
			DomainObject domOrg = DomainObject.newInstance(context, strOrganizationId);
			String strTypePattern = DomainConstants.TYPE_ORGANIZATION;
			StringBuilder strRelPattern = new StringBuilder().append(DomainConstants.RELATIONSHIP_DIVISION).append(DCLConstants.COMMA)
					.append(DomainConstants.RELATIONSHIP_COMPANY_DEPARTMENT).append(",").append(DomainConstants.RELATIONSHIP_ORGANIZATION_PLANT)
					.append(DCLConstants.COMMA).append(DomainConstants.RELATIONSHIP_SUBSIDIARY);
			StringList slOrgRelSelect = new StringList();
			StringList slBusSelects = new StringList(2);
			slBusSelects.add(DomainConstants.SELECT_NAME);
			slBusSelects.add(DomainConstants.SELECT_ID);
			List<Map> mlParentOrgs=new MapList();
			mlParentOrgs = domOrg.getRelatedObjects(context, strRelPattern.toString(), strTypePattern, slBusSelects, slOrgRelSelect, false,
					true,
					(short) 0,
					strWhere, 
					null, 0);
			return mlParentOrgs;
		}
		catch (FrameworkException e) {
			throw new DCLException(e.getLocalizedMessage());
		}

	}


	private List<Map>  getFilterDocuments(Context context,String strFilter) throws DCLException{
		try {
			String policyname = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENTS );
			String policyStateReleased = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyname,
					DCLConstants.SYMBOLIC_STATE_RELEASED);
			String policyStateSuperseded = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyname,
					DCLConstants.SYMBOLIC_STATE_SUPERSEDED);
			String policyStateObsolete = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyname,
					DCLConstants.SYMBOLIC_STATE_OBSOLETE);
			String strRelSME = PropertyUtil.getSchemaProperty(context,DCLConstants.SYMBOLIC_RELATIONSHIP_SUBJECT_MATTER_EXPERT);

			String defaultorg=PersonUtil.getDefaultOrganization(context, context.getUser());
			String strOrganizationId = DomainConstants.EMPTY_STRING;
			if(UIUtil.isNullOrEmpty(defaultorg)){
				DomainObject domObjPerson = DomainObject.newInstance(context, PersonUtil.getPersonObjectID(context));
				strOrganizationId = domObjPerson.getInfo(context,
						"to[" + PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_relationship_Employee) + "].from.id");
			}
			else {
				strOrganizationId=DCLUtil.getOrganizationId(context, defaultorg);
			}

			List<Map> mlOrgs=getChildOrganization(context,strOrganizationId,null);

			String strOrgId[]=new String[mlOrgs.size()+1];
			for(int i=0;i<mlOrgs.size();i++)
			{
				Map mOrg=mlOrgs.get(i);
				strOrgId[i]=(String) mOrg.get(DomainConstants.SELECT_ID);
			}
			strOrgId[mlOrgs.size()]=strOrganizationId;

			StringBuilder sbSMEId = new StringBuilder();
			sbSMEId.append("from[").append(strRelSME).append("].to.id");

			StringList slSelects=new StringList();
			slSelects.addAll(DCDocument.getDocumentSelectables(context));
			slSelects.add(sbSMEId.toString());

			String strChckReleasedState=DomainConstants.EMPTY_STRING;
			boolean checkRevision=false;
			if (DCLConstants.ACTIVE.equals(strFilter)) {
				strChckReleasedState="!=";
				checkRevision=true;
			}
			else if (DCLConstants.RELEASED.equals(strFilter))
				strChckReleasedState="==";
			else
				strChckReleasedState = "!=";

			StringBuilder sbSMECheckWhereClause = new StringBuilder();
			sbSMECheckWhereClause.append("(");
			sbSMECheckWhereClause.append(sbSMEId).append("==").append(PersonUtil.getPersonObjectID(context,context.getUser()));
			sbSMECheckWhereClause.append(" && ");

			sbSMECheckWhereClause.append(DomainConstants.SELECT_CURRENT).append(strChckReleasedState).append("const\"").append(policyStateReleased)
			.append("\"");
			sbSMECheckWhereClause.append(" && ");
			if (!strFilter.equals(DCLConstants.SELECT_ALL)) {
				sbSMECheckWhereClause.append(DomainConstants.SELECT_CURRENT).append("!=").append("const\"").append(policyStateSuperseded)
				.append("\"");
				sbSMECheckWhereClause.append(" && ");
				sbSMECheckWhereClause.append(DomainConstants.SELECT_CURRENT).append("!=").append("const\"").append(policyStateObsolete).append("\"");
				sbSMECheckWhereClause.append(" && ");
			}
			sbSMECheckWhereClause.append(DCDocument.getGeneralDocumentCondition(context));
			sbSMECheckWhereClause.append(")");

			StringBuilder sbObjectWhere = new StringBuilder();
			sbObjectWhere.append("(");
			sbObjectWhere.append("(");

			sbObjectWhere.append(DomainConstants.SELECT_CURRENT).append(strChckReleasedState).append("const\"").append(policyStateReleased)
			.append("\"");
			sbObjectWhere.append(" && ");
			if (!strFilter.equals(DCLConstants.SELECT_ALL)) {
				sbObjectWhere.append(DomainConstants.SELECT_CURRENT).append("!=").append("const\"").append(policyStateSuperseded).append("\"");
				sbObjectWhere.append(" && ");
				sbObjectWhere.append(DomainConstants.SELECT_CURRENT).append("!=").append("const\"").append(policyStateObsolete).append("\"");
				sbObjectWhere.append(" && ");
			}
			sbObjectWhere.append(DCDocument.getGeneralDocumentCondition(context));
			sbObjectWhere.append(")");

			sbObjectWhere.append(" || ");
			sbObjectWhere.append(sbSMECheckWhereClause.toString());
			sbObjectWhere.append(")");

			if(checkRevision)
				sbObjectWhere.append(" && ").append(DomainConstants.SELECT_REVISION).append("==last");

			List<Map> mlDocs=new MapList();
			if (PersonUtil.hasAssignment(context, PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_DOCUMENT_CENTER_ADMINISTRATOR))||PersonUtil.hasAssignment(context, PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_VPLM_PROJECT_LEADER))) {

				ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
				mlDocs = documentService.getResponsibleOrganizationDocuments(context, strOrgId, slSelects, sbObjectWhere.toString());
			}

			if (PersonUtil.hasAssignment(context, PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_SUBJECT_MATTER_EXPERT))
					|| PersonUtil.hasAssignment(context, PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_VPLM_PROJECT_LEADER))) {
				String strTypeControlledDocuments = PropertyUtil.getSchemaProperty(context,DCLConstants.SYMBOLIC_TYPE_CONTROLLED_DOCUMENTS);
				if(mlDocs == null ){
					mlDocs = new MapList();
				}
				List<Map> tempMaps = DCLUtil.getObjects(context, strTypeControlledDocuments, DomainObject.QUERY_WILDCARD,
						sbSMECheckWhereClause.toString(), slSelects);
				if(tempMaps != null)
					mlDocs.addAll(tempMaps);			
			}

			mlDocs.addAll(getOwnedDocuments(context, strChckReleasedState, strFilter));
			return DCUtil.filterDuplicateMaps(context, mlDocs);
		}
		catch (FrameworkException e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	private MapList getOwnedDocuments(Context context, String strChckReleasedState, String strFilter) throws DCLException{
		try {
			String policyname = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENTS );
			String policyStateSuperseded = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyname,
					DCLConstants.SYMBOLIC_STATE_SUPERSEDED);
			String policyStateReleased = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyname,
					DCLConstants.SYMBOLIC_STATE_RELEASED);
			String policyStateObsolete = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyname,
					DCLConstants.SYMBOLIC_STATE_OBSOLETE);
			StringList slSelect = new StringList();
			slSelect.addAll(DCDocument.getDocumentSelectables(context));
			slSelect.add(DomainConstants.SELECT_ID);
			slSelect.add(DomainConstants.SELECT_TYPE);
			slSelect.add(DomainConstants.SELECT_NAME);
			slSelect.add(DomainConstants.SELECT_REVISION);
			slSelect.add(DomainConstants.SELECT_OWNER);
			slSelect.add(DomainConstants.SELECT_CURRENT);

			StringBuilder sbWhere = new StringBuilder(256);
			sbWhere.append("(");
			sbWhere.append(DCDocument.getGeneralDocumentCondition(context));
			sbWhere.append(") && (");
			if (!strFilter.equals(DCLConstants.SELECT_ALL)) {
				sbWhere.append(DomainConstants.SELECT_CURRENT).append(strChckReleasedState).append("const\"").append(policyStateReleased).append("\"");
				sbWhere.append(" && ");
				sbWhere.append(DomainConstants.SELECT_CURRENT).append("!=").append("const\"").append(policyStateSuperseded).append("\"");
				sbWhere.append(" && ");
				sbWhere.append(DomainConstants.SELECT_CURRENT).append("!=").append("const\"").append(policyStateObsolete).append("\"");
				sbWhere.append(" && ");
			}
			sbWhere.append(DomainConstants.SELECT_OWNER+"==\""+context.getUser()+"\"");
			sbWhere.append(")");

			return DomainObject.findObjects(context, PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CONTROLLED_DOCUMENTS),
					null, sbWhere.toString(), slSelect);
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map preProcessAddDocumentsToLibrary(Context context, String args[]) throws DCLException{
		try {
			Map mReturnMap = new HashMap<>();
			String docIds = DomainConstants.EMPTY_STRING;
			StringBuilder sbURL = new StringBuilder();
			Map programMap = JPO.unpackArgs(args);
			String[] emxTableRowId = (String[]) programMap.get(DCLConstants.EMX_TABLE_ROW_ID);
			for(String TableRowId : emxTableRowId){
				TableRowId tr = new TableRowId(TableRowId);
				if(UIUtil.isNotNullAndNotEmpty(docIds))
					docIds = docIds + "," + tr.getObjectId();
				else
					docIds = tr.getObjectId();
			}
			sbURL.append("var submitURL=\"../common/emxFullSearch.jsp?field=TYPES=type_DocumentFamily:CURRENT=policy_ContainerRev2.state_Approved&table=LCClassificationList&submitURL=../documentcontrol/enoDCLExecute.jsp?dclAction=ENODCLDocumentUI:addDocumentToDocumentFamily&selection=single");
			sbURL.append("&appendedDocIds=");
			sbURL.append(XSSUtil.encodeForJavaScript(context, docIds));
			sbURL.append("&submitAction=refreshCaller");
			sbURL.append("\";\n showModalDialog(submitURL,250,250,true);");
			mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, sbURL.toString());
			return mReturnMap;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	/**
	 * Method is used to add Documents to document family and Library
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return the Map which contains the javascript alert to notify that document is added to family and library.
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map addDocumentToDocumentFamily(Context context,String args[]) throws DCLException{
		try{
			String strinvalidDocList = "invalidDocList";
			String strvalidDocList = "validDocList";
			String strvalidDocNameList = "validDocNameList";
			String strAppendedDocIds = "appendedDocIds";
			Map documentMap = new HashMap<>();
			ControlledDocumentService service = DCLServiceUtil.getControlledDocumentService(context);
			String strParentId = DomainConstants.EMPTY_STRING;
			DomainObject docObj = null;
			String strSubClass = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_RELATIONSHIP_SUBCLASS);
			Map programMap = JPO.unpackArgs(args);
			String strEmxTableRowId[] = (String[]) programMap.get(DCLConstants.EMX_TABLE_ROW_ID);
			Map dataMap = new HashMap();

			//parameter only availabe when docs selected from Actions Menu
			String[] docIds = (String[]) programMap.get(strAppendedDocIds);    			   
			StringList slRel = new StringList();
			slRel.add(DomainRelationship.SELECT_FROM_NAME);
			slRel.add(DomainRelationship.SELECT_TO_NAME);

			StringBuilder sbClassificationPath = new StringBuilder();
			String strDocName = DomainConstants.EMPTY_STRING;
			String strDocLib = DomainConstants.EMPTY_STRING;
			String strDocFamily = DomainConstants.EMPTY_STRING;
			Map mReturnMap = new HashMap<>();
			StringBuilder sbSubmitURL = new StringBuilder();

			for(String strTableRowId:strEmxTableRowId){
				TableRowId tr = new TableRowId(strTableRowId);
				String strObjectId = tr.getObjectId();
				strParentId = tr.getParentObjectId();

				//parent id is the Id of the Document Family
				dataMap.put("parentId", strObjectId);

				//if multiple documents are selected to be added to a particular Document Family(from Actions menu of "My Documents" tab)
				if((!DCLUtil.isNullOrEmpty(docIds))){
					docIds= docIds[0].split(",");
					dataMap.put("childIds", docIds);
				}
				//if Document to be added to Library via RMB command
				else
					dataMap.put("childIds", new String[]{strParentId});


				documentMap = service.checkIfDocumentIsAlreadyConnectedToFamily(context, strObjectId, (String[])dataMap.get("childIds"));

				// getting details of Document amily and the Document Library to which it is connected
				DomainObject dobj = DomainObject.newInstance(context, strObjectId);
				Map map = dobj.getRelatedObject(context,
						strSubClass,
						false,
						null,
						slRel);

				strDocLib = (String) map.get(DomainRelationship.SELECT_FROM_NAME);
				strDocFamily = (String) map.get(DomainRelationship.SELECT_TO_NAME);
				sbClassificationPath.append(strDocLib).append("-->").append(strDocFamily).append("\\n");
			}

			//create alert for documents that are added to the library
			if(!DCLUtil.isNullOrEmpty((String[])documentMap.get(strvalidDocList))){
				dataMap.put("childIds", documentMap.get(strvalidDocList));
				String[] arg = JPO.packArgs(dataMap);
				String strResult = JPO.invoke(context, "emxClassification", null, "addEndItems", arg, String.class);
				StringList docList = (StringList)documentMap.get(strvalidDocNameList);
				String strClassificationRequiredText = EnoviaResourceBundle.getProperty(context, "emxComponentsStringResource", context.getLocale(), "emxComponents.Properties.ClassificationPaths");
				String strMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.DocumentAddedtoLibrary",
						new String[]{docList.toString().substring(1, docList.toString().length()-1), docList.toString().substring(1, docList.toString().length()-1)}, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				sbSubmitURL.append("alert(\"").append(strMessage).append("\\n").append(strClassificationRequiredText).append("\\n").append(sbClassificationPath.toString());
			}
			//create alert for documents that are not added to the library
			if(!DCLUtil.isNullOrEmpty((StringList)documentMap.get(strinvalidDocList))){
				if(DCLUtil.isNullOrEmpty(sbSubmitURL.toString())){
					sbSubmitURL.append("alert(\"");
				}
				StringList invalidDocList = (StringList)documentMap.get(strinvalidDocList);
				String strDocNotAddedMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.DocumentNotAddedtoLibrary",
						new String[]{invalidDocList.toString().substring(1, invalidDocList.toString().length()-1), invalidDocList.toString().substring(1, invalidDocList.toString().length()-1),strDocFamily}, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				sbSubmitURL.append("\\n").append(strDocNotAddedMessage).append("\\n");

			}
			sbSubmitURL.append("\");getTopWindow().closeWindow();");
			mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, sbSubmitURL.toString());

			return mReturnMap;
		}
		catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	public Vector<String> getMyDocuments(Context context, String[] args) throws DCLException{

		try {
			Map programMap = (Map) JPO.unpackArgs(args);
			Vector slLinks = new Vector<String>();
			Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			List<Map> mlObjectList = (List)programMap.get(DCConstants.OBJECTLIST);
			for (Map mDoc : mlObjectList) {
				String strObjectId=(String) mDoc.get(DomainConstants.SELECT_ID);
				String strObjectName=(String) mDoc.get(DomainConstants.SELECT_NAME);
				DomainObject docObj = DomainObject.newInstance(context, strObjectId);
				slLinks.add(formToolTip(context, strObjectId, strObjectName));

			}
			return slLinks;
		} catch (Exception e) {
			throw new DCLException();
		}

	}
	private String formToolTip(Context context, String strObjectId, String strObjectName) throws Exception {
		try {
			StringBuilder sbLink = new StringBuilder(256);

			//Vector<String> slSelects=new StringList();
			StringList slSelects=new StringList();
			slSelects.add(DomainObject.SELECT_NAME);
			slSelects.add(DomainObject.SELECT_TYPE);
			slSelects.add(DomainObject.getAttributeSelect("Title"));
			slSelects.add(DomainObject.SELECT_DESCRIPTION);
			slSelects.add(DomainObject.SELECT_OWNER);

			DomainObject dobj=DomainObject.newInstance(context, strObjectId);
			Map mInfo=dobj.getInfo(context, (StringList)slSelects);
			String strType=(String) mInfo.get(DomainObject.SELECT_TYPE);

			boolean hasPromoteAccess=dobj.checkAccess(context, (short) AccessConstants.cPromote);
			boolean hasDemoteAccess=dobj.checkAccess(context, (short) AccessConstants.cDemote);
			boolean hasModifyAccess=dobj.checkAccess(context, (short) AccessConstants.cModify);

			final String sAdHocRouteName = EnoviaResourceBundle.getProperty(context, "emxFramework.Lifecycle.AdHocRouteName");

			Map routeIndicator = dobj.getRouteInfoForStates(context, sAdHocRouteName);
			ArrayList listStates = new ArrayList();
			String strCurrentState=dobj.getInfo(context, DomainObject.SELECT_CURRENT);

			StateList stateList = dobj.getStates(context);

			for (Iterator itrStates = stateList.iterator(); itrStates.hasNext();) {
				State stState = (State) itrStates.next();
				listStates.add(stState.getName());
			}
			int nIndexOfState = listStates.indexOf(strCurrentState);
			String nextState="";
			if(nIndexOfState+1<listStates.size())
				nextState=(String) listStates.get(nIndexOfState+1);
			String previousState="";
			if(nIndexOfState>=1)
				previousState=(String) listStates.get(nIndexOfState-1);

			sbLink.append("<div style= \"position: relative;display: inline-block;  \" ");
			sbLink.append("onmouseover=\"showTooltip('").append(strObjectName).append("' , '").append(strObjectId).append("' ); \"  ");
			//sbLink.append("showRoute('").append(strObjectId).append("' ); \"  ");
			sbLink.append("onmouseout=\"hideTooltip('").append(strObjectName).append("' , '') \" ");
			sbLink.append(" >");



			sbLink.append(DCUtil.getObjectLink(context, strObjectId, strObjectName));

			sbLink.append("</div>");

			sbLink.append("<div  style=\" visibility: hidden; width: 270px;    ");
			sbLink.append("color: #ffff; text-align: center;border-radius: 6px;  padding: 2px 0; background-color: #f8f8f8; ");
			sbLink.append(" z-index: 4; display:block;  ");
			sbLink.append("position: absolute;  white-space: nowrap;  overflow:visible;\" id='").append(strObjectName).append("' ");
			sbLink.append("onmouseover=\"showTooltip('").append(strObjectName).append("' , '') \" ");
			sbLink.append("onmouseout=\"hideTooltip('").append(strObjectName).append("' , '").append(strObjectId).append("' ) \" ");
			sbLink.append(">");





			sbLink.append("<div style= \"position: relative;display: inline-block; line-height:0;  margin-left: auto ; margin-right: auto  \">");
			//sbLink.append(strObjectName);
			sbLink.append("<img src=\"../common/images/iconActionProperties.png\" style=\"cursor:pointer;\"  alt=\"View\" onclick=\"openViewPage('").append(strObjectId).append("')\"  ");
			sbLink.append(" onmouseover=\"openViewPageDiv('").append(strObjectId).append("')\"  ");
			sbLink.append("onmouseout=\" var viewProperties= document.getElementById('").append(strObjectId).append("');  viewProperties.style.visibility= 'hidden'; \"");
			sbLink.append(">");
			sbLink.append("</img>");

			//div added for View Basic Properties
			sbLink.append("<div  style=\" visibility: hidden; width: 270px; top:20px ;border-style: solid; line-height:0; left: 0; right: 0; ");
			sbLink.append("color: #ffff; text-align: center;border-radius: 6px;  padding: 2px 0; background-color: #f8f8f8; ");
			sbLink.append(" z-index: 4; display:inline-block;  float:left;");
			sbLink.append("position: absolute;  white-space: nowrap;  overflow:visible;\" id='").append(strObjectId).append("' > ");
			sbLink.append("</div>");


			sbLink.append(" <img src=\"../common/images/iconSmallLifecycle.gif\" style=\"cursor:pointer;\"  alt=\"Lifecycle\" title=\"Lifecycle\" onclick=\"openLifecycle('").append(strObjectId).append("')\" /> ");

			if(hasModifyAccess)
				sbLink.append("    <img src=\"../common/images/iconActionEdit.png\" style=\"cursor:pointer;\"  alt=\"Edit\" title=\"Edit\" onclick=\"openEditPage('").append(strObjectId).append("' , '").append(strType).append("' )\" /> ");
			sbLink.append("    <img src=\"../common/images/iconActionPageHistory.gif\" style=\"cursor:pointer;\"  alt=\"History\" title=\"History\" onclick=\"openHistoryPage('").append(strObjectId).append("' , '").append(strType).append("' )\" /> ");
			//sbLink.append("    <img src=\"../common/images/iconStatusValidationError.gif\" style=\"cursor:pointer;\"  alt=\"Blocking Conditions\" title=\"Blocking Conditions\" onclick=\"openConditionsPage('").append(strObjectId).append("' , '").append(strType).append("' )\" /> ");

			sbLink.append("<div  style=\" visibility: hidden;  top:20px ;border-style: solid; line-height:0; left: 0; right: 0; " );
			sbLink.append("color: #ffff; text-align: center;border-radius: 6px;  padding: 2px 0; background-color: #f8f8f8; ");
			sbLink.append(" z-index: 4; display:inline-block;  float:left;");
			sbLink.append("position: absolute;  white-space: nowrap;  overflow:visible;\" width='100%' height='100%' id='").append(strObjectId).append("Blocking' > ");
			sbLink.append("</div>");

			sbLink.append("<span   id='").append(strObjectId).append("Images'> </span>");

			sbLink.append("</div>");

			sbLink.append("<BR/>");

			if(UIUtil.isNotNullAndNotEmpty(previousState))
			{

				if(!hasDemoteAccess)
				{
					sbLink.append(" <span class=\"button\" ");
					sbLink.append(" style=\"background-color: #F5F6F7;");
					sbLink.append(" border:1px solid #b4b6ba;");
					sbLink.append("  border-radius:2px;");
					sbLink.append(" -moz-border-radius:2px;");
					sbLink.append(" color: #5b5d5e;");
					sbLink.append(" padding: 3px 7px;");
					sbLink.append(" font-size: 14px;");
					sbLink.append(" margin:0 3px 0 0;");
					sbLink.append("  -moz-border-radius:2px;");
					sbLink.append("  -webkit-border-radius:2px;");
					sbLink.append("  white-space: nowrap;");
					sbLink.append(" line-height: 16px;");
					sbLink.append("\" ");
					sbLink.append("  > ").append(previousState).append(" </span>");
				}

				else{
					sbLink.append("<a style=\"color: #77797C; text-decoration: none;\" href='../documentcontrol/emxExtendedPageHeaderAction.jsp?action=demote&amp;objectId=").append(XSSUtil.encodeForURL(context,strObjectId)).append("' target='hiddenFrame' ").append(" title='").append("Demote").append("'>");
					sbLink.append("<button type=\"button\" ");
					sbLink.append("class=\"previous\"  ");
					sbLink.append("onmouseover=\"javascript: var tooltip1= document.getElementById('").append(strObjectName).append("');  tooltip1.style.visibility= 'visible';\" ");
					sbLink.append(">");

					sbLink.append(previousState);
					sbLink.append("<img class=\"lc-button-arrow\" src=\"../common/images/utilArrowLeft.png\"/>");
					sbLink.append("</button> ");
					sbLink.append("</a>");
					boolean routeExists = (routeIndicator.containsKey(previousState));
					if(routeExists)
					{
						sbLink.append("<img class=\"lc-button-arrow\" style=\"cursor:pointer;\"  src=\"../common/images/lifecycleRouteWithSignatureW22.gif\" onClick=\"openRoute()\"/>");
					}

				}
			}


			sbLink.append("<span style=\"color:").append(${CLASS:emxUtil}.sColorLink ).append("; cursor:pointer;\" ");
			sbLink.append(">");
			sbLink.append("<button type=\"button\" class=\"status\" ");
			sbLink.append("onmouseover=\"javascript: var tooltip1= document.getElementById('").append(strObjectName).append("');  tooltip1.style.visibility= 'visible';\" ");
			sbLink.append("onClick=\"openLifecycle('").append(strObjectId).append("') \"");
			sbLink.append(">");
			sbLink.append(strCurrentState);
			sbLink.append("</button> ");
			sbLink.append("</span>");

			if(UIUtil.isNotNullAndNotEmpty(nextState))
			{

				boolean routeExists = (routeIndicator.containsKey(strCurrentState));
				if(routeExists)
				{
					StringList slObjectSelect = new StringList(4);
					slObjectSelect.add(DomainObject.SELECT_ID);
					slObjectSelect.add(DomainObject.getAttributeSelect(DomainObject.ATTRIBUTE_ROUTE_BASE_STATE));

					String whrClause    = DomainObject.getAttributeSelect(DomainObject.ATTRIBUTE_ROUTE_BASE_STATE)+"== '"+ "state_"+strCurrentState.replace(" ", "") + "'";

					MapList resultList= dobj.getRelatedObjects(context,
							DomainObject.RELATIONSHIP_OBJECT_ROUTE,
							DomainObject.TYPE_ROUTE,
							slObjectSelect,
							null,
							false,
							true,
							(short) 1,
							"",
							whrClause,
							0);
					Map mRoute=(Map) resultList.get(0);
					String strRouteId=(String) mRoute.get(DomainObject.SELECT_ID);

					sbLink.append("<img class=\"lc-button-arrow\"  style=\"cursor:pointer;\" src=\"../common/images/lifecycleRouteLineW22.gif\" onClick=\"openTreePage('").append(strRouteId).append("') \" />");
				}

				if(!hasPromoteAccess)
				{
					sbLink.append(" <span class=\"button\" ");
					sbLink.append(" style=\"background-color: #F5F6F7;");
					sbLink.append(" border:1px solid #b4b6ba;");
					sbLink.append("  border-radius:2px;");
					sbLink.append(" -moz-border-radius:2px;");
					sbLink.append(" color: #5b5d5e;");
					sbLink.append(" padding: 3px 7px;");
					sbLink.append(" font-size: 14px;");
					sbLink.append(" margin:0 3px 0 0;");
					sbLink.append("  -moz-border-radius:2px;");
					sbLink.append("  -webkit-border-radius:2px;");
					sbLink.append("  white-space: nowrap;");
					sbLink.append(" line-height: 16px;");
					sbLink.append("\"");
					sbLink.append("  > ").append(nextState).append("</span>");
				}
				else
				{

					sbLink.append("<a style=\"color: #77797C; text-decoration: none;\" href='../documentcontrol/emxExtendedPageHeaderAction.jsp?action=promote&amp;objectId=").append(XSSUtil.encodeForURL(context,strObjectId)).append("' target='hiddenFrame'").append(" title='").append("Promote").append("'>");
					sbLink.append("<button  type =\"button\" value=\"Demote\"  ");
					sbLink.append("class=\"next\"   ");
					sbLink.append("onmouseover=\"javascript: var tooltip1= document.getElementById('").append(strObjectName).append("');  tooltip1.style.visibility= 'visible';\" ");
					sbLink.append(">");


					sbLink.append("<img class=\"lc-button-arrow\" src=\"../common/images/utilArrowRight.png\"/>");
					sbLink.append(nextState);
					sbLink.append("</button> ");
					sbLink.append("</a>");

				}
			}

			sbLink.append("</div>");

			return sbLink.toString();
		}  catch (Exception e) {
			throw new Exception(e);

		}
	}
	@com.dassault_systemes.enovia.questionnaire.ExecuteCallable
	public String getBasicProperties(Context context, String args[]) throws Exception {
		try {
			Map<?,?> programMap = (Map<?,?>) JPO.unpackArgs(args);
			String strObjectId[] = (String[])programMap.get(DCLConstants.OBJECTID);

			//Vector<String> slSelects=new StringList();
			StringList slSelects=new StringList();
			slSelects.add(DomainObject.SELECT_NAME);
			slSelects.add(DomainObject.SELECT_TYPE);
			slSelects.add(DomainObject.getAttributeSelect("Title"));
			slSelects.add(DomainObject.SELECT_DESCRIPTION);
			slSelects.add(DomainObject.SELECT_OWNER);

			DomainObject dobj=DomainObject.newInstance(context, strObjectId[0]);
			Map mInfo=dobj.getInfo(context, (StringList)slSelects);
			Map basicKeys=new HashMap();
			basicKeys.put(DomainObject.SELECT_NAME, "Name");
			basicKeys.put(DomainObject.SELECT_TYPE, "Type");
			basicKeys.put(DomainObject.SELECT_DESCRIPTION, "Description");
			basicKeys.put(DomainObject.SELECT_OWNER, "Owner");
			basicKeys.put(DomainObject.getAttributeSelect("Title"), "Title");

			StringBuilder sbLink =new StringBuilder();
			sbLink.append("<table style=\"font-family: arial, sans-serif; top:20px ; width=100%;\" cellpadding=\"10\" >");
			for(int i=0;i<slSelects.size();i++)
				//for(String strKey:slSelects)
			{
				String strKey=(String) slSelects.get(i);
				String strValue=(String) mInfo.get(strKey);
				if(UIUtil.isNotNullAndNotEmpty(strValue))
				{
					sbLink.append("<tr>");
					sbLink.append("<td style=\"padding:4px\" >");
					sbLink.append(basicKeys.get(strKey));
					sbLink.append("</td>");
					sbLink.append("<td style=\"padding:4px\" >");
					sbLink.append(strValue);
					sbLink.append("</td>");
					sbLink.append("</tr>");
				}
			}
			sbLink.append("</table>");

			return "Ajax$" + sbLink.toString();
		}
		catch(MatrixException ex)
		{
			return "Ajax$Error" + ex.getLocalizedMessage();
		}
		catch(Exception ex)
		{
			return "Ajax$Error" + ex.getLocalizedMessage();
		}
	}
	@com.dassault_systemes.enovia.questionnaire.ExecuteCallable
	public String getApproversImage(Context context, String args[]) throws Exception {
		try {
			Map<?,?> programMap = (Map<?,?>) JPO.unpackArgs(args);
			String strObjectId[] = (String[])programMap.get(DCLConstants.OBJECTID);
			ChangeOrderUI changeOrderUI=new ChangeOrderUI();
			changeOrderUI.setId(strObjectId[0]);
			MapList taskMapList = changeOrderUI.getCurrentAssignedTasksOnObject(context);

			String taskTreeTranslatedLink = "";
			String taskApprovalTranslatedLink = "";
			StringBuilder sbLink =new StringBuilder();
			if (taskMapList.size() > 0) {
				for (Iterator itrObjects = taskMapList.iterator(); itrObjects.hasNext();) {
					Map mapObjectInfo = (Map) itrObjects.next();
					String strName = (String)mapObjectInfo.get("name");
					String strInfoType = (String)mapObjectInfo.get("infoType");

					if ("activatedTask".equals(strInfoType)) {

						String taskObjectId = (String)mapObjectInfo.get(ChangeConstants.ID);

						sbLink.append(" <a target=\"hiddenFrame\" class=\"object\" href=\"../common/emxLifecycleApproveRejectPreProcess.jsp?emxTableRowId=");
						sbLink.append(taskObjectId);
						sbLink.append( "^");
						sbLink.append((String)mapObjectInfo.get("parentObjectState"));
						sbLink.append("^^");
						sbLink.append( taskObjectId);
						sbLink.append( "&objectId=");
						sbLink.append( taskObjectId);
						sbLink.append( "&suiteKey=Framework\"><img border='0' src='../common/images/iconActionApprove.png' /></a>");
					}

				}

			}
			System.out.println(sbLink);
			return "Ajax$" + sbLink.toString();
		}
		catch(MatrixException ex)
		{
			return "Ajax$Error" + ex.getLocalizedMessage();
		}
		catch(Exception ex)
		{
			return "Ajax$Error" + ex.getLocalizedMessage();
		}
	}

	/**
	 * Method is used to exclude all the document family ids to which this particular document is already added.
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return the StringList of all the family ids to which the document is already added.
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.matrixone.apps.framework.ui.ExcludeOIDProgramCallable
	public StringList excludeDocumentLibraryIds(Context context,String args[]) throws DCLException{
		try{

			Map programMap = JPO.unpackArgs(args);
			String strControlledDocument = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CONTROLLED_DOCUMENTS);
			String strClassifiedItem = PropertyUtil.getSchemaProperty(context, DomainConstants.RELATIONSHIP_CLASSIFIED_ITEM);
			String strObjectId = DomainConstants.EMPTY_STRING;
			strObjectId = (String) programMap.get(DCLConstants.OBJECTID);
			if(DCLUtil.isNullOrEmpty(strObjectId)){
				String emxTableRowId = (String) programMap.get(DCLConstants.EMX_TABLE_ROW_ID);
				TableRowId tr = new TableRowId(emxTableRowId);
				strObjectId = tr.getObjectId();
			}
			DomainObject dobjCheck = DomainObject.newInstance(context, strObjectId);

			//If document is to be added Library via Library Central UI. 
			if(DCLUtil.isNullOrEmpty(strObjectId) || !dobjCheck.isKindOf(context, strControlledDocument)){
				String stremxTableRowId = (String) programMap.get(DCLConstants.EMX_TABLE_ROW_ID);
				TableRowId tr = new TableRowId(stremxTableRowId);
				strObjectId = tr.getObjectId();
			}

			StringList slExcludeList = new StringList();

			StringList slObject = new StringList();
			slObject.add(DomainObject.SELECT_NAME);
			slObject.add(DomainObject.SELECT_ID);

			StringList slRel = new StringList();
			slRel.add(DomainRelationship.SELECT_FROM_NAME);
			slRel.add(DomainRelationship.SELECT_FROM_ID);
			slRel.add(DomainRelationship.SELECT_TO_NAME);
			DomainObject dobj = DomainObject.newInstance(context, strObjectId);
			MapList ml = dobj.getRelatedObjects(context, strClassifiedItem, DomainObject.QUERY_WILDCARD, slObject, slRel, true, false, (short) 0,
					null, null, 0);

			for(Object obj : ml){
				Map map = (Map) obj;
				String strFromID = (String) map.get(DomainRelationship.SELECT_FROM_ID);
				slExcludeList.add(strFromID);  			   
			}
			return slExcludeList;
		}
		catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method is used to check if both Library Central and DOCO are installed.
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return the boolean value if true the both are intalled and false the one of them or both of them are not installed.
	 * @throws DCLException if operation fails
	 * @exclude
	 */

	public boolean accessForLibraryCentralAndDocumentControl(Context context,String args[]) throws DCLException{
		try{
			String policyName = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENTS);
			String strReleasedState = PropertyUtil.getSchemaProperty(context, DomainConstants.SELECT_POLICY, policyName,
					DCLConstants.SYMBOLIC_STATE_RELEASED);
			String strState = DomainConstants.EMPTY_STRING;
			String strProgramLabel = DomainConstants.EMPTY_STRING;
			Map programMap = JPO.unpackArgs(args);
			String strObjectId = (String) programMap.get(DCLConstants.OBJECTID);
			if(!DCLUtil.isNullOrEmpty(strObjectId))
				strState = DomainObject.newInstance(context, strObjectId).getInfo(context, DomainObject.SELECT_CURRENT);
			else{
				strProgramLabel = (String) programMap.get("DCLDocumentFilter");
			}
			boolean bLBC = FrameworkUtil.isSuiteRegistered(context, "appVersionLibraryCentral", false, null, null);
			if(bLBC && (strState.equals(strReleasedState) || (!DCLUtil.isNullOrEmpty(strProgramLabel)&&strProgramLabel.equals(DCLConstants.RELEASED)))){
				try{
					//  DCLUtil.checkLicenseReserved(context);
					//ComponentsUtil.checkLicenseReserved(context, "ENO_LBC_TP");
					return true;
				}catch(Exception e){
					return false; 
				}
			}
			else
				return false;
		}  catch(Exception exception){
			throw new DCLException(exception.getLocalizedMessage());
		}

	}
	/**
	 * Method is used to show the property page of Controlled Document
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return Map containing ACTION_JAVASCRIPT
	 * @throws  DCLException if operation fails
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> viewDetailsInRMB(Context context,String [] args) throws DCLException
	{
		try {
			Map<?, ?> programMap = (Map) JPO.unpackArgs(args);
			String tableRowId[] = (String[])programMap.get(DCLConstants.EMX_TABLE_ROW_ID);
			String strDocId[] = (String[])programMap.get(DCLConstants.OBJECTID);
			String strDocTemplatePolicy = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_POLICY_CONTROLLED_DOCUMENT_TEMPLATE); 
			StringList slSelects = new StringList();
			slSelects.add(DomainConstants.SELECT_POLICY);

			if(!DCLUtil.isNullOrEmpty(tableRowId)){
				for (String strRowIds : tableRowId) {
					String strRowId=strRowIds;
					TableRowId tableRowID=new TableRowId(strRowId);
					strDocId[0] = tableRowID.getObjectId();
				}
			}

			Map mDocInfo = DCLUtil.getInfo(context, strDocId[0], slSelects);
			String strPolicy = (String)mDocInfo.get(DomainConstants.SELECT_POLICY);

			Map<String, String> mReturnMap  = new HashMap<String, String>();
			DCLUtil.encodeFunctionForJavaScript(context, false, "viewDetailsInRMB", strDocTemplatePolicy,strPolicy,strDocId[0]);
			mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "viewDetailsInRMB('"+strDocTemplatePolicy+"','"+strPolicy+"','"+strDocId[0]+"')");
			return mReturnMap;

		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}

	}

	public Map<?,?> showDocumentCategoryRange(Context context,String []args) throws Exception{
		try{
			Map mpReturn = new HashMap();
			StringList slRange=new StringList();
			StringList slDisplayRange = new StringList();
			Map<?, ?> programMap = (Map) JPO.unpackArgs(args);
			Map<?,?> requestMap=(Map)programMap.get("requestMap");
			String strType=(String)requestMap.get(DomainConstants.SELECT_TYPE);
			if(!DCLUtil.isNullOrEmpty(strType)){
				if(strType.contains(",")){
					StringList slType=FrameworkUtil.split(strType, ",");
					strType=(String)slType.get(1);
				}
			}
			strType=PropertyUtil.getSchemaProperty(context, strType);

			String strAttrName=DomainObject.EMPTY_STRING;
			String strInterface=DCLUtil.getInterfaceForTypeDocumentCategory(context, strType);
			if(!DCLUtil.isNullOrEmpty(strInterface)){
				String strAttrOnType=DCLUtil.mqlCommand(context, "list attribute $1 where $2", false, "*","owner==\""+strInterface+"\"");
				strAttrName=strInterface+".Document Category";
				registerAttribute(context, strAttrName);
				if(!DCLUtil.isNullOrEmpty(strAttrOnType)&&strAttrOnType.contains(strAttrName)){

					slRange = FrameworkUtil.getRanges(context, strAttrName);

					if (!DCLUtil.isNullOrEmpty(slRange)) {
						slDisplayRange = i18nNow.getAttrRangeI18NStringList(strAttrName, slRange, context.getSession().getLanguage());
					}
				}
			}
			else{
				slRange.add(" ");
				slDisplayRange.add(" ");
			}

			mpReturn.put(PeriodicReviewConstants.FIELD_CHOICES, slRange);
			mpReturn.put(PeriodicReviewConstants.FIELD_DISPLAY_CHOICES, slDisplayRange);

			return mpReturn;
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}

	}

	private void registerAttribute(Context context, String strAttributeName) throws DCLException {
		try{
			ContextUtil.pushContext(context, DCLConstants.USER_AGENT, null,null);
			String strSymbolicName = "attribute_"+strAttributeName.trim().replaceAll(" ","");
			Boolean isRegistered = strAttributeName.equals(PropertyUtil.getSchemaProperty(context, strSymbolicName));
			if(!isRegistered)
				MqlUtil.mqlCommand(context, "add property $1 on program $2 to attribute $3", strSymbolicName, "eServiceSchemaVariableMapping.tcl", strAttributeName);

			ContextUtil.popContext(context);
		}
		catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	public boolean showCreateFormOnRefrenceDocField(Context context, String[] args) throws DCLException{
		boolean isDisplay = false;
		try { 
			List<String> slPolicies = new StringList();
			Map<?,?> hmParamMap = (Map<?,?>) JPO.unpackArgs(args); 
			String strActionMode = (String) hmParamMap.get(DCLConstants.ACTION_MODE);
			if(!DCLUtil.isNullOrEmpty(strActionMode) && strActionMode.equals("ReferenceDocument")) {
				isDisplay = true;
			} 
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		return isDisplay;
	}

	public String getCreateDocumentFromRefrenceDocumentUIScript(Context context, String args[]) throws DCLException {
		try {
			return "<script>\n"
					+ "var chooserTypeActual = $(\"[name=btnTypeActual]\");"
					+ "chooserTypeActual[0].onclick = function () { javascript:showChooser('../common/emxTypeChooser.jsp?type=type_Document&amp;SelectType=singleselect&amp;SelectAbstractTypes=false&amp;InclusionList=type_DOCUMENTS&amp;ReloadOpener=false&amp;ExclusionList=enoDocumentCommon.CreateDocuments.TypeExclusionList&amp;fieldNameActual=TypeActual&amp;fieldNameDisplay=TypeActualDisplay&amp;fieldNameOID=TypeActualOID&amp;suiteKey=DocumentCommon','600','600','true','','TypeActual') } \n"
					+ "</script>";
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map getTemplaterespOrg(Context context, String args[]) throws DCLException {
		try {
			String strPeriodicReviewInterval = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_PERIODIC_REVIEW_INTERVAL);
			Map hmParamMap = (Map) JPO.unpackArgs(args);
			Map mpReturn = new HashMap<>();
			String[] templateId = (String[]) hmParamMap.get("templateId");
			DomainObject dobj = DomainObject.newInstance(context, templateId[0]);
			String strOrg = dobj.getInfo(context, DomainConstants.SELECT_ORGANIZATION);
			mpReturn.put(DCLConstants.ACTION_AJAX, strOrg);
			return mpReturn;
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Get Range Values for Transfer Action field
	 * 
	 * @param context
	 *            the ENOVIA <code>Context</code> object
	 * @param args
	 *            holds packed arguments
	 * @return Map of Range Values
	 * @throws DCLException
	 *             if operation fails
	 */
	public Map<String, StringList> getTranferActions(Context context, String args[]) throws DCLException {
		try {
			String strLanguage = context.getSession().getLanguage();
			Map programMap = (Map) JPO.unpackArgs(args);
			StringList sResponseRangeList = new StringList();
			StringList sResponseDisplayRangeList = new StringList();
			sResponseRangeList.add(DCLConstants.DCL_SME);
			sResponseRangeList.add(DCLConstants.DCL_IMPL_ORG_REPRESENTATIVE);
			Map<String, StringList> rangeMap = new HashMap<String, StringList>();
			String strTransferActionSME = EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.TransferAction.SubjectMatterExpert");
			String strTransferActionDCA = EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentControl.TransferAction.ImplementingOrganizationRepresentative");
			sResponseDisplayRangeList.add(strTransferActionSME);
			sResponseDisplayRangeList.add(strTransferActionDCA);
			rangeMap.put(DCLConstants.FIELD_CHOICES, sResponseRangeList);
			rangeMap.put(DCLConstants.FIELD_DISPLAY_CHOICES, sResponseDisplayRangeList);
			return rangeMap;
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Set the selected value to the Form field
	 * 
	 * @param context
	 *            the ENOVIA <code>Context</code> object
	 * @param args
	 *            holds packed arguments
	 * @return String value to be set
	 * @throws DCLException
	 *             if operation fails
	 */
	public String getFieldValues(Context context, String args[]) throws DCLException {
		try {
			Map programMap = (Map) JPO.unpackArgs(args);
			Map requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			String strAppendFields = (String) requestMap.get(DCLConstants.APPENDFIELDS);
			String strReturnValue = DCLConstants.DCL_IMPL_ORG_REPRESENTATIVE;
			if (UIUtil.isNullOrEmpty(strAppendFields)) {
				strReturnValue = DomainConstants.EMPTY_STRING;
			}

			if ("DCLTransferAssignmentSME".equals(strAppendFields))
				strReturnValue = DCLConstants.DCL_SME;

			return strReturnValue;

		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map transferAssignments(Context context, String[] args) throws DCLException {
		try {
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			Map<String, String> returnMap = new HashMap<String, String>();
			StringBuilder sbReturnScript = new StringBuilder();
			Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
			String[] arrTranferAction = (String[]) programMap.get("TransferAction");
			String[] arrToAssignee = (String[]) programMap.get("ToAssigneeOID");
			String[] arrFromAssignee = (String[]) programMap.get("FromAssigneeOID");
			String[] arrPostProcessURL = (String[]) programMap.get("postProcessURL");
			String strAppendFields = arrTranferAction[0];
			String strFromAssignee = arrFromAssignee[0];
			String strToAssignee = arrToAssignee[0];
			String strPostProcessURL = arrPostProcessURL[0];
			String strAlertMessage = null;
			int objCount = 0;
			if (!UIUtil.isNullOrEmpty(strFromAssignee) && !UIUtil.isNullOrEmpty(strToAssignee)) {
				if (strFromAssignee.equals(strToAssignee)) {
					strAlertMessage = EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
							"enoDocumentControl.AlertMsg.SelectDifferentAssignee");
					if (!UIUtil.isNullOrEmpty(strPostProcessURL)){
						DCLUtil.encodeFunctionForJavaScript(context, false, "transferAssignments",strAlertMessage);
						returnMap.put(DCLConstants.ACTION_JAVASCRIPT, "transferAssignments('"+strAlertMessage+"')");
						return returnMap;
					}
				}
				if (strAppendFields.equals(DCLConstants.DCL_IMPL_ORG_REPRESENTATIVE))
					objCount = documentService.transferImplementingOrgRepresentative(context, strFromAssignee, strToAssignee);

				if (strAppendFields.equals(DCLConstants.DCL_SME) && !UIUtil.isNullOrEmpty(strFromAssignee) && !UIUtil.isNullOrEmpty(strToAssignee))
					objCount = documentService.transferSMEReviewAssignments(context, strFromAssignee, strToAssignee);

				strAlertMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.AlertMsg.OwnershipTransferred",
						new String[] { String.valueOf(objCount) }, null, context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
				sbReturnScript.append("alert(\"").append(XSSUtil.encodeForJavaScript(context, strAlertMessage)).append("\")");
				returnMap.put(DCLConstants.ACTION_JAVASCRIPT, sbReturnScript.toString());

			}
			return returnMap;
		}
		catch (Exception e) {
			throw new DCLException(e);
		}
	}


	public Vector<String> getDocumentCategoryValues(Context context,String []args) throws Exception{
		try{
			Map<?,?>programMap=(Map)JPO.unpackArgs(args);
			Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			List<Map> mlObjectList = (List)programMap.get(DCConstants.OBJECTLIST);
			StringList slAttrVal=new StringList();
			Vector<String> slCategory=new Vector<String>();
			String strAttributeValue=DomainConstants.EMPTY_STRING;
			String stri18nAttributeValue=DomainConstants.EMPTY_STRING;
			for (Map mDoc : mlObjectList) {
				String strObjectId=(String) mDoc.get(DomainConstants.SELECT_ID);
				DomainObject doObj=DomainObject.newInstance(context, strObjectId);
				String strInterfaceName=DCLUtil.getInterfaceForTypeDocumentCategory(context, doObj.getInfo(context, DomainObject.SELECT_TYPE));
				String strAttributeName = strInterfaceName+".Document Category";
				strAttributeValue=doObj.getAttributeValue(context, strAttributeName);
				if(DomainConstants.EMPTY_STRING.equals(strAttributeValue))
					slAttrVal.add(DomainConstants.EMPTY_STRING);
				else
				{
					slAttrVal.add(i18nNow.getAttrRangeI18NStringList(strAttributeName, new StringList(strAttributeValue), context.getSession().getLanguage()).get(0));
				}
			}
			slCategory.addAll(slAttrVal);
			return slCategory;
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}

	}

	public String getDocumentCategoryValue(Context context,String []args) throws Exception{
		try{
			Map<?,?>programMap=(Map)JPO.unpackArgs(args);
			Map<?,?>paramMap=(Map)programMap.get("paramMap");
			Map<?,?>requestMap=(Map)programMap.get("requestMap");
			String strObjectId=(String)paramMap.get("objectId");
			if(DCLUtil.isNullOrEmpty(strObjectId)){
				strObjectId=(String)requestMap.get("selTemplateId");
			}
			String strAttributeValue=DomainConstants.EMPTY_STRING;
			String stri18nAttributeValue=DomainConstants.EMPTY_STRING;
			if(!DCLUtil.isNullOrEmpty(strObjectId)){
				DomainObject doObj=DomainObject.newInstance(context, strObjectId);
				String  strInterfaceName=DCLUtil.getInterfaceForTypeDocumentCategory(context, doObj.getInfo(context, DomainObject.SELECT_TYPE));
				String strAttributeName = strInterfaceName+".Document Category";
				strAttributeValue=doObj.getAttributeValue(context, strAttributeName);
				if(DomainConstants.EMPTY_STRING.equals(strAttributeValue))
					stri18nAttributeValue = DomainConstants.EMPTY_STRING;
				else
				{
					stri18nAttributeValue = i18nNow.getAttrRangeI18NStringList(strAttributeName, new StringList(strAttributeValue), context.getSession().getLanguage()).get(0).toString();
				}

			}
			return stri18nAttributeValue;
		}

		catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	public Map getDocumentCategoryInSearch(Context context,String []args) throws Exception{
		try{
			String strRangeValue=DomainConstants.EMPTY_STRING;
			String stri18nRangeValue=DomainConstants.EMPTY_STRING;
			Map<String,String> returnMap=new HashMap();
			Map<?,?> programMap=JPO.unpackArgs(args);
			String strAttrName=DomainObject.EMPTY_STRING;
			String strDocumentType=PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CONTROLLED_DOCUMENTS);
			String strSubType=DCLUtil.mqlCommand(context, "print type $1 select $2 $3", false, strDocumentType,"derivative","dump");
			List<String> slSubType=FrameworkUtil.split(strSubType, ",");
			for(String strType:slSubType){
				String strInterface=DCLUtil.getInterfaceForTypeDocumentCategory(context, strType);
				if(!DCLUtil.isNullOrEmpty(strInterface)){
					String strAttrOnType=DCLUtil.mqlCommand(context, "list attribute $1 where $2", false, "*","owner==\""+strInterface+"\"");
					strAttrName=strInterface+".Document Category";
					if(!DCLUtil.isNullOrEmpty(strAttrOnType)&&strAttrOnType.contains(strAttrName)){
						String strRange=DCLUtil.mqlCommand(context, "Print attribute $1 select $2 $3", false, strAttrName, "range", "dump");
						List<String> slAttrRange=FrameworkUtil.split(strRange, ",");
						for(String str:slAttrRange){
							strRangeValue = str.substring(2);
							if(DomainConstants.EMPTY_STRING.equals(strRangeValue))
								returnMap.put(DomainConstants.EMPTY_STRING, DomainConstants.EMPTY_STRING);
							else 
							{
								stri18nRangeValue = i18nNow.getAttrRangeI18NStringList(strAttrName, new StringList(strRangeValue), context.getSession().getLanguage()).get(0).toString();
								returnMap.put(strRangeValue, stri18nRangeValue);
							}
						}
					}
				}
			}
			return returnMap;
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	public String getDocumentCategoryValueInSearch(Context context,String []args) throws DCLException{
		try{
			String strDocCategory=DomainConstants.EMPTY_STRING;
			String strObjectId=args[0];
			String strRange=DCLUtil.mqlCommand(context, "Print bus $1 select $2 dump", false, strObjectId, "attribute[Document Category]");
			return strRange;
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	@com.matrixone.apps.framework.ui.ProgramCallable
	public MapList getConnectedChangeActionstoDocument(Context context,String []args) throws DCLException{
		final String STR_TYPE_CHANGE_ORDER =  PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_ORDER);
		final String STR_TYPE_CHANGE_ACTION =  PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_ACTION);
		final String STR_TYPE_CHANGE_REQUEST =  PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CHANGE_REQUEST);
		String strCA=DomainConstants.EMPTY_STRING;
		StringList slCA=new StringList();

		MapList mlCA=new MapList();
		try{

			Map<?,?> programMap=JPO.unpackArgs(args);
			String strParentId=(String)programMap.get(DCConstants.PARENT_OID);
			if(UIUtil.isNullOrEmpty(strParentId))
				strParentId=(String) programMap.get(DCLConstants.OBJECTID);
			ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);
			List lChange = documentService.getConnectedChange(context, strParentId);
			//looping in reverse order because we want to show the new CO/CA/CR at the end.
			for(int i=lChange.size()-1;i>=0;i--) {
				List<Map> listTemp = (List<Map>)lChange.get(i);
				for(Map mp:listTemp){
					System.out.println("map --> "+mp);
					Map mp1= new HashMap<>();
					String strType = mp.get(DomainObject.SELECT_TYPE).toString();
					if(STR_TYPE_CHANGE_ACTION.equalsIgnoreCase(strType)){
						mp1.put(DomainObject.SELECT_ID, (String)mp.get(DomainObject.SELECT_ID));
					}
					if (! mp1.isEmpty()) {
						mlCA.add(mp1);
					}
				}
			}
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
		mlCA=(MapList) DCUtil.filterDuplicateMaps(context, mlCA);
		return mlCA;
	}


	/*********************************************** Moved from ${CLASS:ENODocumentBase}.java *************************************************************/	

	/**
	 * This method will be called to get all "Documents" which are in states configured in Property File
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds no value
	 * @return MapList containing Document details
	 * @throws Exception if the operation fails
	 * @exclude
	 */
	@com.matrixone.apps.framework.ui.ProgramCallable
	public List<Map> getAllActiveStatesDocuments(Context context,String args[]) throws Exception
	{

		return getDocumentsByFilter(context, DCLConstants.ACTIVE);
	}

	private  List<Map> getDocumentsByFilter(Context context, String strFilterKey) throws MatrixException
	{
		List<Map> mlDocs = new MapList();
		StringBuilder sbWhere = new StringBuilder(256);
		sbWhere.append("( ");
		sbWhere.append(DCDocument.getGeneralDocumentCondition(context));
		sbWhere.append(" ) && (");
		sbWhere.append(DomainConstants.SELECT_OWNER+"==\""+context.getUser()+"\"");
		sbWhere.append(")");

		String strStates = EnoviaResourceBundle.getProperty(context,"enoDocumentCommon.common.states.Released");
		StringList slStates = FrameworkUtil.split(strStates, DCConstants.SEPARATOR_COMMA);

		String strCheckState=DomainConstants.EMPTY_STRING;
		if(strFilterKey.equals("Active"))
		{
			strCheckState="!=";
			sbWhere.append("&&").append(DomainConstants.SELECT_REVISION).append("==last");
			mlDocs.addAll(getAdditionalDocuments(context,"enoDocumentCommon.Active.AdditionalDocuments"));
		}

		if(strFilterKey.equals("Released"))
		{
			strCheckState="==";
			mlDocs.addAll(getAdditionalDocuments(context,"enoDocumentCommon.Relased.AdditionalDocuments"));
		}
		if(strFilterKey.equals("All"))
		{
			mlDocs.addAll(getAdditionalDocuments(context,"enoDocumentCommon.Active.AdditionalDocuments"));
			mlDocs.addAll(getAdditionalDocuments(context,"enoDocumentCommon.Relased.AdditionalDocuments"));
			mlDocs.addAll(getFilterDocuments(context, "All"));
		}

		List<Map> mlDocuments=DCUtil.filterDuplicateMaps(context,mlDocs);
		return mlDocuments;
	}

	private List<Map> getAdditionalDocuments(Context context, String strKey) throws MatrixException {

		String strJpoKey = EnoviaResourceBundle.getProperty(context,strKey);
		List<String> slJPOList=FrameworkUtil.split(strJpoKey, ",");
		List mlDocs=new MapList();
		for(String strJPO:slJPOList)
		{
			List<String> slJPOMethodList=FrameworkUtil.split(strJPO, ":");
			String strProgramName=slJPOMethodList.get(0);
			String strMethodName=slJPOMethodList.get(1);
			mlDocs = JPO.invoke(context, strProgramName, null, strMethodName, null, MapList.class);
		}


		return mlDocs;
	}

	/**
	 * This method will be called to get all "Documents" which are in Released States
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds no value
	 * @return MapList containing Document details
	 * @throws Exception if the operation fails
	 * @exclude
	 */
	@com.matrixone.apps.framework.ui.ProgramCallable
	public List<Map> getReleasedStateDocuments(Context context,String args[]) throws MatrixException 
	{
		return getDocumentsByFilter(context, "Released");
	}

	/**
	 * Method to refresh the My Document Tab
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds nothing
	 * @return javascript to be executed in the browser
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map refreshMyDocTab(Context context, String[] args){
		Map mReturn = new HashMap();
		mReturn.put(DCConstants.ACTION_INCLUDEJSP, "../common/scripts/emxUIConstants.js");
		mReturn.put(DCConstants.ACTION_JAVASCRIPT, "var frame = findFrame(getTopWindow(),'DCMyDocumentsTab');\n if(frame) \n frame.location.href = frame.location.href;");
		return mReturn;
	}




	/**
	 * expandProgram used to get Reference Documents for controlled document and make it as read only
	 * @param context context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments
	 * @return MapList list of reference documents map
	 * @throws Exception 
	 * @throws DCLException if operation fails
	 */
	@com.matrixone.apps.framework.ui.ProgramCallable
	public MapList getReferenceDocumentsForDocument (Context context,String[] args) throws Exception
	{
		try {
			MapList mlReferenceDocuments = new MapList();
			Map programMap=(Map) JPO.unpackArgs(args);
			String strObjectId = (String) programMap.get(DCConstants.OBJECTID);
			String strRelId=(String) programMap.get("relId");
			if(!UIUtil.isNullOrEmpty(strRelId)){
				DomainRelationship doRel=DomainRelationship.newInstance(context, strRelId);
				StringList slSelect= new StringList();
				slSelect.add(DomainRelationship.SELECT_TO_ID);
				slSelect.add(DomainRelationship.SELECT_TO_NAME);
				String strRel[]={strRelId};
				List<Map> mlRelInfo=DomainRelationship.getInfo(context,strRel, slSelect);
				for(Map mp:mlRelInfo){
					String strRelID=(String)mp.get(DomainRelationship.SELECT_TO_ID);
					String strRelName=(String)mp.get(DomainRelationship.SELECT_TO_NAME);
					if(strRelID.equals((String) programMap.get("parentId")))
						return mlReferenceDocuments;
				}
			}
			MapList mlRefrencedDocuments=DCDocument.getReferenceDocuments(context,strObjectId);
			for(int i=0;i<mlRefrencedDocuments.size();i++)
			{
				Map mpReferenceDocs = (Map) mlRefrencedDocuments.get(i);
				mpReferenceDocs.put("RowEditable","readonly");
				mpReferenceDocs.put("disableSelection","true");
				mpReferenceDocs.put("direction",(String)mpReferenceDocs.get(DomainRelationship.SELECT_DIRECTION));
				if("to".equals((String)mpReferenceDocs.get(DomainRelationship.SELECT_DIRECTION))){
					mpReferenceDocs.put("hasChildren", "false");
				}
			}
			return mlRefrencedDocuments;
		}  catch (Exception e) {
			throw new Exception(e);
		}
	}
	/**
	 * Method to get the type name for which the create document form is defined
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments.
	 * @return Map of Ajax with type name
	 * @throws Exception if Operation fails
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String,String> getSelectedType(Context context,String[] args) throws Exception{

		try
		{
			String strSelType=DomainConstants.EMPTY_STRING;
			Map<String,String> mpReturn = new HashMap<String,String> ();
			Map programMap = (Map) JPO.unpackArgs(args);
			String[] strSelectedType = (String[]) programMap.get("selectedType");
			String[] strSuitKey = (String[]) programMap.get("suiteKey");
			strSelType=PropertyUtil.getSchemaProperty(context, "type_"+strSelectedType[0]);
			String strCommand = "print type $1 select $2 dump";
			String result = MqlUtil.mqlCommand(context, strCommand, false, strSelType, "kindof[CONTROLLED DOCUMENTS]");

			try{
				if(result.equalsIgnoreCase("TRUE"))
					strSelType = strSelType.replace(" ","") + "|" + result;
				else
					strSelType = strSelType.replace(" ","");
				mpReturn.put(DCConstants.ACTION_AJAX, strSelType);
			}
			catch(Exception e)
			{
				strSelType=DCUtil.getParentTypeForm(context,strSelType,strSuitKey[0]);
				mpReturn.put(DCConstants.ACTION_AJAX, strSelType.replace(" ",""));
				return mpReturn;
			}
			return mpReturn;
		}
		catch(Exception e)
		{
			throw new Exception(e.getLocalizedMessage());
		}
	}

	public void preProcessforTemplateChooser(Context context, String[] args) throws Exception {
		System.out.println("in method");
	}

	public StringList getCARespOrganization(Context context,String[] args) throws Exception{
		StringList slRespOrg=new StringList();
		try{
			Map<?,?> programMap= JPO.unpackArgs(args); 
			List<Map> mlObjectList=(MapList)programMap.get(DCConstants.OBJECTLIST);
			for (Map mp:mlObjectList){
				String strObjectId=(String)mp.get(DomainConstants.SELECT_ID);
				DomainObject doObj= DomainObject.newInstance(context, strObjectId);
				String strOrg=doObj.getInfo(context, DomainObject.SELECT_ORGANIZATION);
				String strLink=DCUtil.getObjectLink(context, DCLUtil.getOrganizationId(context, strOrg), strOrg);
				slRespOrg.add(strLink);
			}
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
		return slRespOrg;
	}

	/**
	 * Method to check if autoVue is installed or not.
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments.
	 * @return boolean true/false if AutoVue is installed or not
	 * @throws Exception if Operation fails
	 */
	public boolean isAutoVueInstalled(Context context, String args[]) throws DCLException{
		try {
			String strAutoVue = "AutoVue Viewer";
			String sResults = MqlUtil.mqlCommand(context, "execute program $1", "eServiceHelpAbout.tcl");
			sResults = sResults.trim();
			if(sResults.contains(strAutoVue))
				return true;
			else
				return false;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method to get the file attached to QSD and its corresponding Markups, else if the object is the connected file directly get the markups
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments.
	 * @return MapList of Markups ids
	 * @throws Exception if Operation fails
	 */
	public MapList getFileMarkupContentData(Context context, String args[]) throws DCLException{
		try {
			String strActiveVersionRel = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_relationship_ActiveVersion);
			MapList finalMarkupList = new MapList();
			StringList activeVersionList = new StringList();

			MapList markupList = new MapList();
			StringList objectSelects = new StringList("from[" + strActiveVersionRel + "].to.id");
			objectSelects.add("from[" + strActiveVersionRel + "].to.name");

			Map programMap = JPO.unpackArgs(args);
			String strObjectId = (String) programMap.get(DCConstants.OBJECTID);
			DomainObject dobj = DomainObject.newInstance(context, strObjectId);
			activeVersionList = dobj.getInfoList(context, "from[" + strActiveVersionRel + "].to.id");
			if(DCLUtil.isNullOrEmpty(activeVersionList)){
				String strFromObjectId = dobj.getInfo(context, "to[" + strActiveVersionRel + "].from.id");
				if(!DCLUtil.isNullOrEmpty(strFromObjectId))
					finalMarkupList = getMarkupsData(context, args);
			}
			else{
				for(int i =0 ; i<activeVersionList.size(); i++){
					Map markupMap = new HashMap<>();
					markupMap.put("id", activeVersionList.get(i).toString());
					finalMarkupList.add(markupMap);	
				}
			}
			return finalMarkupList;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Method to get the Markups attached to the file
	 * @param context the ENOVIA <code>Context</code> object.
	 * @param args holds packed arguments.
	 * @return MapList of Markups ids
	 * @throws Exception if Operation fails
	 */
	public MapList getMarkupsData(Context context,String args[]) throws DCLException{
		try {
			MapList finalMarkupList = new MapList();
			StringList markupList = new StringList();
			String strActiveVersionRel = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_relationship_ActiveVersion);
			String strC3DViewableRel = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_RELATIONSHIP_C3DVIEWABLE);
			String strMarkup = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_RELATIONSHIP_MARKUP);

			Map programMap = JPO.unpackArgs(args);
			String strObjectId = (String) programMap.get(DCConstants.OBJECTID);
			markupList = DomainObject.newInstance(context, strObjectId).getInfoList(context, "from[" + strC3DViewableRel + "].to.from[" + strMarkup + "].to.id");
			for(int i =0 ; i<markupList.size(); i++){
				Map markupMap = new HashMap<>();
				markupMap.put("id", markupList.get(i).toString());
				markupMap.put("hasChildren", "false");
				finalMarkupList.add(markupMap);
			}
			return finalMarkupList;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	public boolean showDocumentCategoryField(Context context,String []args) throws Exception{
		try{
			Map<?, ?> programMap = (Map) JPO.unpackArgs(args);
			String strType=(String)programMap.get(DomainConstants.SELECT_TYPE);
			if(!DCLUtil.isNullOrEmpty(strType)){
				if(strType.contains(",")){
					StringList slType=FrameworkUtil.split(strType, ",");
					strType=(String)slType.get(1);
				}
			}
			strType=PropertyUtil.getSchemaProperty(context, strType);
			String strObjectId=(String)programMap.get("objectId");
			if(!DCLUtil.isNullOrEmpty(strObjectId)){
				DomainObject doObj=DomainObject.newInstance(context, strObjectId);
				strType=doObj.getInfo(context, DomainObject.SELECT_TYPE);
			}

			String strInterface=DCLUtil.getInterfaceForTypeDocumentCategory(context, strType);
			if(!DCLUtil.isNullOrEmpty(strInterface)){
				String strAttrOnType=DCLUtil.mqlCommand(context, "list attribute $1 where $2", false,  "*","owner==\""+strInterface+"\"");
				if(!DCLUtil.isNullOrEmpty(strAttrOnType)&&strAttrOnType.contains(strInterface+".Document Category"))
					return true;
				else
					return false; 
			}

			else
				return false;
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	@com.matrixone.apps.framework.ui.IncludeOIDProgramCallable
	public List<String> getResponsibleOrganizationList(Context context, String args[]) throws DCLException {
		try {
			Map programMap = (Map) JPO.unpackArgs(args);
			List<String> slIncludeOrganizations = new StringList();
			Person per=Person.getPerson(context, context.getUser());
			DomainObject dPerObj=DomainObject.newInstance(context, per.getId(context));
			String str=per.getId(context);
			StringList objProductSelects = new StringList();
			objProductSelects.add(DomainObject.SELECT_ID);
			objProductSelects.add(DomainObject.SELECT_NAME);

			StringList relProductSelects = new StringList(1);
			relProductSelects.add(DCLConstants.ID_CONNECTION);

			List<Map> mlComp=	dPerObj.getRelatedObjects(context, DomainObject.RELATIONSHIP_MEMBER, DomainObject.TYPE_ORGANIZATION, objProductSelects,
					relProductSelects, true, false, (short) 1, null, null, (short) 0);

			for(Map mp:mlComp){
				String strOrg=(String)mp.get(DomainObject.SELECT_ID);
				//System.out.println("ENODCLDocumentUIBase: getResponsibleOrganizationList - Next Member Relation Organization ID Found for Person = " + strOrg);
				//System.out.println("ENODCLDocumentUIBase: getResponsibleOrganizationList - Person is Employee of: " + per.getCompanyId(context));
				slIncludeOrganizations.add(strOrg);
				if((Person.getPerson(context).getCompanyId(context)).equals(strOrg)){
					//System.out.println("ENODCLDocumentUIBase: getResponsibleOrganizationList - Person is Both Employee and Member of: " + per.getCompanyId(context));					
					List<Map> mlOrg=getChildOrganization(context, (String)mp.get(DomainObject.SELECT_ID), null);
					for(Map mOrg:mlOrg){
						//System.out.println("ENODCLDocumentUIBase: getResponsibleOrganizationList - Adding Child Org: " + (String)mOrg.get(DomainObject.SELECT_ID));
						slIncludeOrganizations.add((String)mOrg.get(DomainObject.SELECT_ID));
					}
				}
			}

			return slIncludeOrganizations;
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}

	}

	public String showResponsibleOrgDisplayField(Context context, String args[])
	{
		StringBuffer output=new StringBuffer();
		output.append("<input type=\"hidden\" name=\"ResponsibleOrganizationDisplay\"></input>");					
		return output.toString();
	}

	public String showResponsibleOrgField(Context context, String args[])
	{
		StringBuffer output=new StringBuffer();
		output.append("<input type=\"hidden\" name=\"ResponsibleOrganization\"></input>");		
		return output.toString();
	}

	public String showResponsibleOrgOIDField(Context context, String args[])
	{
		StringBuffer output=new StringBuffer();
		output.append("<input type=\"hidden\" name=\"ResponsibleOrganizationOID\"></input>");		
		return output.toString();
	}



	public boolean checkForPrintInPropertyPage(Context context, String args[]) throws DCLException {
		try {
			boolean show = false;
			String strRenderPDF = String.valueOf(DCLUtil.getRederPDFValue(context)); //check if render pdf is false
			if (!DCLUtil.isNullOrEmpty(strRenderPDF)){

				if(strRenderPDF.equalsIgnoreCase("false"))
					return false;

			}
			else
				return true;
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		return true;
	}


	public boolean checkForReleasedFilter(Context context, String args[]) throws DCLException {
		try {
			Map programMap = JPO.unpackArgs(args);
			boolean show = false;
			String strFilter = (String) programMap.get("DCLDocumentFilter");

			// Added for use in Regulatory Guideline table
			if (DCLUtil.isNullOrEmpty(strFilter)){
				return false;
			}
			String strRenderPDF =  String.valueOf(DCLUtil.getRederPDFValue(context)); //check if render pdf is false
			if (!DCLUtil.isNullOrEmpty(strFilter) && !DCLUtil.isNullOrEmpty(strRenderPDF)){

				if(!strFilter.equals(DCLConstants.RELEASED) ||strRenderPDF.equalsIgnoreCase("false"))
					return false;
			}
			else
				return true;
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		return true;
	}

	public List<String> getNameOfChangeObject(Context context, String args[]) throws Exception {
		List<String> retList=new StringList();

		Map programMap = (Map) JPO.unpackArgs(args);
		Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
		List<Map> mlObjectList = (List)programMap.get(DCConstants.OBJECTLIST);

		for (Map mDoc : mlObjectList) {
			String strObjectId=(String) mDoc.get(DomainConstants.SELECT_ID);

			DomainObject docObj = DomainObject.newInstance(context, strObjectId);
			String name=docObj.getInfo(context, "name");

			retList.add(DCUtil.getObjectLink(context, strObjectId, name));
		}
		return retList;
	}

	/**
	 * Method is used to get existing Documents
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return Map return the map to execute JSP to call JavaScript
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String, String> actionSearchDocumentsForCopyExisting(Context context, String[] args) throws DCLException {
		try {
			Map<String, String> mReturnMap = new HashMap<>();
			StringBuilder sbSubmitURL = new StringBuilder();
			sbSubmitURL.append("var submitURL =\"");
			sbSubmitURL.append("../common/emxFullSearch.jsp?field=TYPES=type_CONTROLLEDDOCUMENTS:POLICY=policy_ControlledDocuments&form=DCLDocumentsSearchFilters");
			sbSubmitURL.append("&massPromoteDemote=false&table=DCLDocumentsSearch&selection=single&submitURL=../documentcontrol/enoDCLExecute.jsp?dclAction=");
			sbSubmitURL.append("ENODCLDocumentUI:copyExistingDocument\";");
			//	sbSubmitURL.append("getTopWindow().location.href = submitURL;");
			sbSubmitURL.append("showModalDialog(submitURL, 600, 400, false);");
			mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, sbSubmitURL.toString());
			return mReturnMap;
		}
		catch (Exception e) {
			throw new DCLException(e);
		}
	}

	/**
	 * Method is used to get existing Reference Documents
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return Map return the map to execute JSP to call JavaScript
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String, String> actionSearchDocumentsForAddExistingReferenceDocuments(Context context, String[] args) throws DCLException {
		try {
			Map<String, String> mReturnMap = new HashMap<>();
			final Map<?, ?> programMap = JPO.unpackArgs(args);
			String[] arrObjectId = (String[]) programMap.get("objectId");

			StringBuilder sbSubmitURL = new StringBuilder();
			sbSubmitURL.append("var submitURL =\"");
			sbSubmitURL.append("../common/emxFullSearch.jsp?field=TYPES=type_DOCUMENTS:POLICY!=policy_Version,policy_ControlledDocumentTemplate&form=DCLDocumentsSearchFilters&");
			sbSubmitURL.append("table=DCLDocumentsSearch&massPromoteDemote=false&submitURL=../documentcontrol/enoDCLExecute.jsp?dclAction=ENODCLAdminActions:addReferenceDocuments&");
			sbSubmitURL.append("selection=multiple&excludeOIDprogram=ENODCLDocumentUI:excludeReferenceDocument&objectId="+arrObjectId[0]+"\";");
			//sbSubmitURL.append("getTopWindow().location.href = submitURL;");
			sbSubmitURL.append("showModalDialog(submitURL, 600, 400, false);");

			mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, sbSubmitURL.toString());
			return mReturnMap;
		}
		catch (Exception e) {
			throw new DCLException(e);
		}
	}

	/**
	 * Method is used to get existing Organizations
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return Map return the map to execute JSP to call JavaScript
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String, String> actionSearchImplementingOrganizations(Context context, String[] args) throws DCLException {
		try {
			Map<String, String> mReturnMap = new HashMap<>();
			final Map<?, ?> programMap = JPO.unpackArgs(args);
			String[] arrObjectId = (String[]) programMap.get("objectId");

			StringBuilder sbSubmitURL = new StringBuilder();
			sbSubmitURL.append("var submitURL =\"");
			sbSubmitURL.append("../common/emxFullSearch.jsp?field=TYPES=Organization&form=AEFSearchOrganizationForm&table=DOCOOrganizationChooserDetails&selection=multiple&submitURL=../documentcontrol/enoDCLExecute.jsp?dclAction=ENODCLAdminActions:addImplementingOrganizations&submitAction=refreshCaller&excludeOIDprogram=ENODCLEffectivityUI:excludeConnectedImplementingOrganization&showInitialResults=true&objectId="+arrObjectId[0]+"\";");
			//sbSubmitURL.append("../common/emxIndentedTable.jsp?table=DOCOOrganizationChooserDetails&selection=multiple&postProcessURL=../documentcontrol/enoDCLExecute.jsp?dclAction=ENODCLAdminActions:addImplementingOrganizations&submitAction=refreshCaller&program=ENODCLEffectivityUI:getAllOrganization&objectId="+arrObjectId[0]+"\";");	
			//sbSubmitURL.append("getTopWindow().location.href = submitURL;");
			sbSubmitURL.append("showModalDialog(submitURL, 600, 400, false);");
			mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, sbSubmitURL.toString());
			return mReturnMap;
		}
		catch (Exception e) {
			throw new DCLException(e);
		}
	}
	public String getSummaryReprotColumnChangeActionAssignee(Context context, String[] args)throws Exception
	{
		Map programMap = (Map) JPO.unpackArgs(args);
		String strObjectId=(String) programMap.get("currentObjectId");
		DomainObject dobj=DomainObject.newInstance(context,strObjectId);
		String strRelTechnicalAssignee=PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_RELATIONSHIP_TECHNICAL_ASSIGNEE);
		String strName = dobj.getInfo(context,"from["+strRelTechnicalAssignee+"].to.name");
		if(UIUtil.isNotNullAndNotEmpty(strName))
			return  PersonUtil.getFullName(context, strName);
		else
			return DomainConstants.EMPTY_STRING;

	}
	public String getSummaryReprotColumnFileRevision(Context context, String[] args)throws Exception
	{
		Map programMap = (Map) JPO.unpackArgs(args);
		String strObjectId=(String) programMap.get("currentObjectId");
		DomainObject dobj=DomainObject.newInstance(context,strObjectId);
		String strName = dobj.getInfo(context,CommonDocument.SELECT_REVISION);
		if(UIUtil.isNotNullAndNotEmpty(strName))
			return strName;
		else
			return DomainConstants.EMPTY_STRING;

	}
	public String getSummaryReprotColumnFileSize(Context context, String[] args)throws Exception
	{
		Map programMap = (Map) JPO.unpackArgs(args);
		String strObjectId=(String) programMap.get("currentObjectId");
		String strFileSize=(String) programMap.get(CommonDocument.SELECT_FILE_SIZE);
		if(UIUtil.isNotNullAndNotEmpty(strFileSize))
		{	 
			String retStr = "";
			try{
				double dblFileSize = Double.parseDouble(strFileSize);
				DecimalFormat decFormat = new DecimalFormat("0.00");
				if(dblFileSize <= 512){
					retStr = strFileSize + " B";
				} else if(dblFileSize > 512 && dblFileSize <= (1024*512)){
					retStr = decFormat.format(dblFileSize / 1024) + " KB";
				}else if(dblFileSize > (1024*512) && dblFileSize <= (1024*1024*512)){
					retStr = decFormat.format(dblFileSize / (1024*1024)) + " MB";
				}else if(dblFileSize > (1024*1024*512)){
					retStr = decFormat.format(dblFileSize / (1024*1024*1024)) + " GB";
				}else{
					retStr = strFileSize;
				}
			}catch(NumberFormatException ex){
				retStr = strFileSize;
			}
			return retStr;
		}
		else
			return DomainConstants.EMPTY_STRING;

	}
	public String getSummaryReportFieldOriginatorValue(Context context, String[] args)throws Exception
	{
		Map programMap = (Map) JPO.unpackArgs(args);
		String strObjectId=(String) programMap.get("currentObjectId");
		DomainObject dobj=DomainObject.newInstance(context,strObjectId);
		String strAttrOriginator=PropertyUtil.getSchemaProperty(context,DomainSymbolicConstants.SYMBOLIC_attribute_Originator);
		String strName = dobj.getAttributeValue(context, strAttrOriginator);
		if(UIUtil.isNotNullAndNotEmpty(strName))
			return  PersonUtil.getFullName(context, strName);
		else
			return DomainConstants.EMPTY_STRING;

	}

	public Map getTrainingEnabledRangeDCLCreateControlledDocumentForm(Context context,String[] args) throws DCLException
	{
		Map attributeRangeReturnMap = new HashMap();
		String strTrainingEnabledAttribute = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_TRAINING_ENABLED);
		try {
			StringList attributeRangeValueList = FrameworkUtil.getRanges(context, strTrainingEnabledAttribute);
			if (!attributeRangeValueList.isEmpty() && null != attributeRangeValueList) {
				attributeRangeReturnMap.put("field_choices", attributeRangeValueList);
				attributeRangeReturnMap.put("field_display_choices",
						i18nNow.getAttrRangeI18NStringList(strTrainingEnabledAttribute, attributeRangeValueList, context.getSession().getLanguage()));
			}
		}
		catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
		return attributeRangeReturnMap;
	}

	public String getTrainingEnabledFieldFormTypeControlledDocumentEdit(Context context, String args[]) throws DCLException {
		List<String> slResponse = new StringList();
		StringBuilder sBuff = new StringBuilder();
		try {
			Map programMap = (Map) JPO.unpackArgs(args);
			Map paramMap = (Map) programMap.get("paramMap");
			String ObjectId = paramMap.get(DCConstants.OBJECTID).toString();
			String strTemplateToDocumentRel = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_RELATIONSHIP_TEMPLATE_TO_DOCUMENT);
			String strTrainingEnabledAttribute = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_TRAINING_ENABLED);
			StringList strTrainingEnabledAttributeRangeList = FrameworkUtil.getRanges(context, strTrainingEnabledAttribute);
			StringList stri18nTrainingEnabledAttributeRangeList = i18nNow.getAttrRangeI18NStringList(strTrainingEnabledAttribute, strTrainingEnabledAttributeRangeList, context.getSession().getLanguage());
			StringBuilder sbTemplateIdToDocument = new StringBuilder();
			sbTemplateIdToDocument.append("from[").append(strTemplateToDocumentRel).append("].to.id");
			StringList slSelects = new StringList(3);
			slSelects.add(DomainObject.getAttributeSelect(strTrainingEnabledAttribute));
			slSelects.add(sbTemplateIdToDocument.toString());

			Map mDocInfo = DCLUtil.getInfo(context, ObjectId, slSelects);
			String strConnectedTemplateId = (String) mDocInfo.get(sbTemplateIdToDocument.toString());
			String strTrainingEnabledAttributeValue = (String) mDocInfo.get(DomainObject.getAttributeSelect(strTrainingEnabledAttribute));

			sBuff.append("<select name=\"TrainingEnabled\" id=\"TrainingEnabledId\" title=\"Training Enabled\" ");
			if(UIUtil.isNotNullAndNotEmpty(strConnectedTemplateId))
				sBuff.append("disabled ");
			sBuff.append(">");
			for(int i=0;i<strTrainingEnabledAttributeRangeList.size();i++){
				sBuff.append("<option value=\"").append(strTrainingEnabledAttributeRangeList.get(i).toString()).append("\"");
				if(strTrainingEnabledAttributeValue.equals(strTrainingEnabledAttributeRangeList.get(i).toString()))
					sBuff.append(" selected ");
				sBuff.append(">").append(stri18nTrainingEnabledAttributeRangeList.get(i).toString()).append("</option>");
			}
			sBuff.append("</select>");
			slResponse.add(sBuff.toString());
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
		return sBuff.toString();
	}
	public String getTrainingEnabledValue(Context context,String []args) throws Exception{
		try{
			Map<?,?>programMap=(Map)JPO.unpackArgs(args);
			Map<?,?>paramMap=(Map)programMap.get("paramMap");
			Map<?,?>requestMap=(Map)programMap.get("requestMap");
			String strObjectId=(String)paramMap.get("objectId");
			if(DCLUtil.isNullOrEmpty(strObjectId)){
				strObjectId=(String)requestMap.get("selTemplateId");
			}
			String strAttributeValue=DomainConstants.EMPTY_STRING;
			String stri18nAttributeValue=DomainConstants.EMPTY_STRING;
			if(!DCLUtil.isNullOrEmpty(strObjectId)){
				DomainObject doObj=DomainObject.newInstance(context, strObjectId);
				String strType=doObj.getInfo(context, DomainObject.SELECT_TYPE);
				String strAttributeName = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_TRAINING_ENABLED);
				strAttributeValue=doObj.getAttributeValue(context, strAttributeName);
				//stri18nAttributeValue = i18nNow.getAttrRangeI18NStringList(strAttributeName, new StringList(strAttributeValue), context.getSession().getLanguage()).get(0).toString();
			}
			return strAttributeValue;
		}

		catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}
	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map getSubjectMatterExpertOfTemplate(Context context, String[] args)throws Exception
	{
		String strTypePerson = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_Person);
		String strTypeMemberList = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_MemberList);

		Map programMap = (Map) JPO.unpackArgs(args);

		String[] selTemplateId=(String[]) programMap.get("selTemplateId");

		DomainObject domDocTemp=new DomainObject(selTemplateId[0]);
		String relSME=PropertyUtil.getSchemaProperty(context,"relationship_SubjectMatterExpert");

		List slSelect=new StringList();
		slSelect.add(DomainObject.SELECT_ID);
		slSelect.add(DomainObject.SELECT_NAME);

		List slRoles=new StringList();
		slRoles.add(PeriodicReviewConstants.SMEROLE_OWNER);
		slRoles.add(PeriodicReviewConstants.SMEROLE_TEMPORARY);

		PeriodicReviewService periodicReview=PeriodicReviewServiceUtil.getPeriodicReviewService(context);
		List<Map> mlSME=periodicReview.getPeriodicReviewRelatedData(context, selTemplateId[0], slRoles, strTypeMemberList+","+strTypePerson, (List)slSelect, "");
		Iterator itr=mlSME.iterator();

		String strSMEId="";
		String strSMEName="";

		while(itr.hasNext())
		{
			Map mpSME=(Map)itr.next();
			if(strTypeMemberList.equals(mpSME.get(DomainConstants.SELECT_TYPE)))
			{
				strSMEName=(String)mpSME.get(DomainConstants.SELECT_NAME);
				strSMEId=(String)mpSME.get(DomainConstants.SELECT_ID);
				break;
			}
			else
			{
				strSMEName=(String)mpSME.get(DomainConstants.SELECT_NAME);
				strSMEId=(String)mpSME.get(DomainConstants.SELECT_ID);
			}
		}

		Map retMap=new HashMap();
		retMap.put(DCLConstants.ACTION_AJAX, strSMEName+"|"+strSMEId);
		return retMap;
	}

	public StringList getDomainEditAccess(Context context, String[] args) throws DCLException
	// public List<Boolean> getDomainEditAccess(Context context, String[] args) throws DCLException
	{
		String strTypeMemberList = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_MEMBER_LIST);
		String strTypePerson = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_Person);
		String strRoleSubjectMatterExpert = PropertyUtil.getSchemaProperty(context,DCLConstants.SYMBOLIC_ROLE_SUBJECT_MATTER_EXPERT);
		String strRoleLeader = PropertyUtil.getSchemaProperty(context,DCLConstants.SYMBOLIC_ROLE_VPLM_PROJECT_LEADER);
		try
		{
			Map<?,?> programMap = (Map) JPO.unpackArgs(args);
			Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			String strObjectID=(String) requestMap.get(DCConstants.OBJECTID);

			DomainObject dobj = DomainObject.newInstance(context,strObjectID);

			StringList slTempSMEAssignmentRole = new StringList(PeriodicReviewConstants.SMEROLE_OWNER);
			PeriodicReviewService periodicReviewService = PeriodicReviewServiceUtil.getPeriodicReviewService(context);

			List<Map> mlSME= periodicReviewService.getPeriodicReviewRelatedData(context, strObjectID, slTempSMEAssignmentRole, strTypePerson+","+strTypeMemberList, new StringList(DomainObject.SELECT_ID), "");

			Map mpObj;
			StringList memberList=new StringList();

			if(mlSME!=null || mlSME.size()>0)
			{
				mpObj=mlSME.get(0);
				String smeId=(String)mpObj.get(DomainObject.SELECT_ID);

				DomainObject domSME=DomainObject.newInstance(context,smeId);

				if(domSME.isKindOf(context, strTypeMemberList))
				{
					StringList objSelects = new StringList();
					objSelects.add(DomainConstants.SELECT_ID);

					String strRelListMember = PropertyUtil.getSchemaProperty(context,DomainSymbolicConstants.SYMBOLIC_relationship_ListMember);
					MapList idList = domSME.getRelatedObjects(context, strRelListMember,strTypePerson, objSelects, new StringList(), false, true, (short)1, "", "",0);
					Iterator<Map> itr=idList.iterator();

					while(itr.hasNext())
					{
						Map mpMemberObj=itr.next();
						String objId=(String)mpMemberObj.get(DomainObject.SELECT_ID);
						Person personObj=new Person();
						personObj.setId(objId);

						if(personObj.hasRole(context, strRoleSubjectMatterExpert)||personObj.hasRole(context, strRoleLeader))
							memberList.add(personObj.getName());
					}
				}
				else
					memberList.add(domSME.getInfo(context, DomainObject.SELECT_NAME));
			}

			MapList mobjectList = (MapList)programMap.get(DCConstants.OBJECTLIST);
			StringList sAccessList = new StringList();

			for(Object mObjectMap:mobjectList)
			{
				Map mPerson = (Map) mObjectMap;
				String strPersonObjProjName=(String) mPerson.get(DomainConstants.SELECT_NAME);
				if(strPersonObjProjName.endsWith("_PRJ"))
				{
					String strPersonObjName=strPersonObjProjName.substring(0, strPersonObjProjName.length()-4);
					if(memberList.contains(strPersonObjName))
						sAccessList.add(String.valueOf(false));
					else 
						sAccessList.add(String.valueOf(true));
				}
				else
					sAccessList.add(String.valueOf(false));
			}
			return sAccessList;
		}
		catch(Exception ex)
		{
			throw new DCLException(ex);
		}

	}

	@com.matrixone.apps.framework.ui.IncludeOIDProgramCallable
	public List<String> getPersonAndMemberListSME(Context context, String args[]) throws DCLException 
	{
		String strTypePerson = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_Person);
		String strPolicyPerson = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_policy_Person);
		String strTypeMemberList = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_type_MemberList);
		String strPolicyMemberList = PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_policy_MemberList);

		String strRelSME = PropertyUtil.getSchemaProperty(context, PeriodicReviewConstants.SYMBOLIC_RELATIONSHIP_SUBJECT_MATTER_EXPERT);
		String strRoleSME = PropertyUtil.getSchemaProperty(context, PeriodicReviewConstants.SYMBOLIC_ROLE_SUBJECT_MATTER_EXPERT);
		String strRoleLeader = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ROLE_VPLM_PROJECT_LEADER);
		String strStateActiveMemberList = PropertyUtil.getSchemaProperty(context, "policy",strPolicyMemberList, "state_Active");
		String strStateActivePerson = PropertyUtil.getSchemaProperty(context, "policy",strPolicyPerson, "state_Active");

		try 
		{
			PeriodicReviewService periodicReview=PeriodicReviewServiceUtil.getPeriodicReviewService(context);
			Map programMap = (Map) JPO.unpackArgs(args);

			List<String> slIncludePersons = new StringList();

			StringList objSelects = new StringList();
			objSelects.add(DomainObject.SELECT_ID);
			objSelects.add(DomainObject.SELECT_NAME);

			StringBuilder sbWhere=new StringBuilder();
			sbWhere.append(DomainConstants.SELECT_CURRENT).append("==").append("const\"").append(strStateActivePerson).append("\"");

			StringList slPersons=PersonUtil.getPersonFromRole(context, strRoleSME);
			slPersons.addAll(PersonUtil.getPersonFromRole(context, strRoleLeader));



			Iterator itr=slPersons.iterator();
			while(itr.hasNext())
			{
				DomainObject perObj=PersonUtil.getPersonObject(context, itr.next().toString());
				String curState=perObj.getInfo(context, "current");
				if(strStateActivePerson.equals(curState))
					slIncludePersons.add(perObj.getId(context));
			}

			sbWhere=new StringBuilder();
			sbWhere.append(DomainConstants.SELECT_CURRENT).append("==").append("const\"").append(strStateActiveMemberList).append("\"");

			MapList mlPersons=DomainObject.findObjects(context, strTypeMemberList,null, sbWhere.toString(), objSelects);
			itr=mlPersons.iterator();

			while(itr.hasNext())
			{
				String memberListId=((Map)itr.next()).get(DomainObject.SELECT_ID).toString();
				List<Map> mlMembers=periodicReview.getSMEMembersOfMemberList(context, DomainObject.newInstance(context,memberListId));
				if(mlMembers!=null && !mlMembers.isEmpty())
					slIncludePersons.add(memberListId);
			}

			String objectId=(String)programMap.get("objectId");

			if(UIUtil.isNotNullAndNotEmpty(objectId))
			{
				List<Map> mpSMEInfo=periodicReview.getPeriodicReviewRelatedData(context, objectId, new StringList(), strTypePerson+","+strTypeMemberList,objSelects , "");

				itr=mpSMEInfo.iterator();

				while(itr.hasNext())
				{
					Map smeMap=(Map)itr.next();
					String objId=(String)smeMap.get(DomainConstants.SELECT_ID);

					if(strTypeMemberList.equals((String)smeMap.get(DomainConstants.SELECT_TYPE)))
						slIncludePersons.remove(objId);
				}
			}

			return slIncludePersons;
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	public List<String> getControlledPrintInfo(Context context,String []args) throws Exception{
		try{
			Map<?,?>programMap=(Map)JPO.unpackArgs(args);
			Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			List<Map> mlObjectList = (List)programMap.get(DCConstants.OBJECTLIST);
			ControlledPrintingService service= new ControlledPrintingServiceImpl();

			List<String> slControlledPrint=new StringList();
			for (Map mDoc : mlObjectList) {
				String strObjectId=(String) mDoc.get(DomainConstants.SELECT_ID);
				DomainObject doObj=DomainObject.newInstance(context, strObjectId);
				StringBuilder sbLink=new StringBuilder();
				sbLink.append("../emxIndentedTable.jsp?table=ControlledPrintTable&program=ENOControlledPrint:getControlledPrint&sortColumnName=PrintDate&sortDirection=descending&selection=multiple&toolbar=ControlledPrintRecallMenu&objectId=");
				sbLink.append( XSSUtil.encodeForJavaScript(context, strObjectId));
				String strControlledPrintNumber=Integer.toString(service.getControlledPrintRecipients(context, doObj).size());
				String sCPUrl  = XSSUtil.encodeForHTML(context, "javascript:emxTableColumnLinkClick('" + sbLink.toString() + "','800','575',false,'popup','')");
				slControlledPrint.add("<a  href=\""+sCPUrl+"\">"+strControlledPrintNumber+"</a>&#160;");
			}
			return slControlledPrint;
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	/**
	 * Get filter values map for My Documents table
	 * @param context the ENOVIA <code>Context</code> object
	 * @param args holds packed arguments
	 * @return filter values map for Document List table
	 * @throws DCLException if operation fails
	 * @exclude
	 */
	public Map getDocumentFilterValues(Context context, String[] args)
			throws DCLException {
		try {
			StringList slChoice = new StringList(2);
			slChoice.addElement(DCLConstants.ACTIVE);
			slChoice.addElement(DCLConstants.RELEASED);
			slChoice.addElement(DCLConstants.SELECT_ALL);
			StringList slDisplay = new StringList();
			slDisplay.addElement(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentCommon.Label.Active"));
			slDisplay.addElement(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentCommon.Label.Released"));
			slDisplay.addElement(EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
					"enoDocumentCommon.Label.All"));
			Map rangeMap = new HashMap();
			rangeMap.put(DCLConstants.FIELD_CHOICES, slChoice);
			rangeMap.put(DCLConstants.FIELD_DISPLAY_CHOICES, slDisplay);
			return rangeMap;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}   
	}

	public Map getReferenceDocumentCategoryRanges(Context context, String[] args)
			throws DCLException {
		try {
			StringList slChoice = new StringList(2);
			StringList slDisplay = new StringList();
			List<String> slCategory=DCUtil.getCategoryRangeValues(context,"enoDocumentControl.ReferenceDocuments.ContextualCategoryRangeValues");
			slChoice.add("");
			slDisplay.add("");
			for(String strCategory:slCategory){
				slChoice.add(strCategory);
				String strDisplayValue=strCategory;
				try{
					strDisplayValue=EnoviaResourceBundle.getProperty(context, "enoDocumentControlStringResource", context.getLocale(),
							"enoDocumentControl.Range.Document_Classification." + strCategory.replace(" ", "_"));
				}catch(Exception e1){
					strDisplayValue=strCategory;
				}
				slDisplay.add(strDisplayValue);
			}
			Map rangeMap = new HashMap();
			rangeMap.put(DCLConstants.FIELD_CHOICES, slChoice);
			rangeMap.put(DCLConstants.FIELD_DISPLAY_CHOICES, slDisplay);
			return rangeMap;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}   
	}

	public List<String> getReferenceDocumentCategoryValue(Context context,String []args) throws Exception{
		try{
			Map<?,?>programMap=(Map)JPO.unpackArgs(args);
			Map<?,?> requestMap = (Map) programMap.get(DCLConstants.REQUESTMAP);
			List<Map> mlObjectList = (List)programMap.get(DCConstants.OBJECTLIST);
			List<String> slCategoryValue=new StringList();
			for (Map mDoc : mlObjectList) {
				String strRelId=(String) mDoc.get("id[connection]");
				String	strDocumentClassification = DomainRelationship.getAttributeValue(context, strRelId, "Document Classification");
				if(!DCLUtil.isNullOrEmpty(strDocumentClassification))
				     slCategoryValue.add(EnoviaResourceBundle.getProperty(context, "enoDocumentControlStringResource", context.getLocale(),
						"enoDocumentControl.Range.Document_Classification." + strDocumentClassification.replace(" ", "_")));
				else
				   slCategoryValue.add(DomainConstants.EMPTY_STRING);
			}
			return slCategoryValue;
		}catch(Exception e){
			throw new DCLException(e.getLocalizedMessage());
		}
	}

	public void updateReferenceDocumentCategoryValue(Context context, String args[]) throws DCLException {
		try {

			Map programMap=(Map) JPO.unpackArgs(args);
			Map requestMap=(Map) programMap.get(DCLConstants.REQUESTMAP);
			Map paramMap = (Map) programMap.get(DCLConstants.PARAMMAP);
			String strNewValue = (String) paramMap.get(DCLConstants.NEW_VALUE);
			String strRelId = (String) paramMap.get(DCLConstants.RELID);
			DomainRelationship.setAttributeValue(context, strRelId, "Document Classification", strNewValue);
		}
		catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}
	}


	public MapList renderForm(Context context, String args[]) throws Exception {
		try {
			Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
			Map requestMap = (Map) programMap.get("requestMap");
			String strObjectId = (String) requestMap.get("objectId");
			String selectedIds = (String) requestMap.get("selectedIds");
			List<String> slSelectedIds = FrameworkUtil.split(selectedIds, "|");
			String strNameLable=EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),"enoDocumentControl.Label.Name");
			String strTypeLable=EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),"enoDocumentControl.Label.Type");
			String strTitleLable=EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),"enoDocumentControl.Label.Title");
			String strRefDocLable=EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),"enoDocumentControl.Label.ReferenceCategory");

			MapList customerAttFields = new MapList();
			for (String strId : slSelectedIds) {
				if(!DCLUtil.isNullOrEmpty(strId)){
					DomainObject dobj=DomainObject.newInstance(context,strId);
					String strName=dobj.getInfo(context,"name");
					String strType=dobj.getInfo(context,"type");


					HashMap  fieldMap = new HashMap<>();
					fieldMap.put("expression_businessobject", "empty");
					fieldMap.put(UICache.LABEL, strTypeLable);
					fieldMap.put(UICache.NAME, "RefDocType" + "$" + strId);
					UIComponent.modifySetting(fieldMap, "Editable", "false");
					UIComponent.modifySetting(fieldMap, "Field Type", "program");
					UIComponent.modifySetting(fieldMap, "program", "ENODCLDocumentUI");
					UIComponent.modifySetting(fieldMap, "function", "getTypeOfRefernceDocument");



					HashMap fieldMap1 = new HashMap<>();
					fieldMap1.put("expression_businessobject", "empty");
					fieldMap1.put(UICache.LABEL, strNameLable);
					fieldMap1.put(UICache.NAME, "RefDocName" + "$" + strId);
					UIComponent.modifySetting(fieldMap1, "Editable", "false");
					UIComponent.modifySetting(fieldMap1, "Field Type", "program");
					UIComponent.modifySetting(fieldMap1, "program", "ENODCLDocumentUI");
					UIComponent.modifySetting(fieldMap1, "function", "getNameOfRefernceDocument");

					HashMap fieldMap2 = new HashMap<>();
					fieldMap2.put("expression_businessobject", "empty");
					fieldMap2.put(UICache.LABEL, strTitleLable);
					fieldMap2.put(UICache.NAME, "RefDocTitle" + "$" + strId);
					UIComponent.modifySetting(fieldMap2, "Editable", "false");
					UIComponent.modifySetting(fieldMap2, "Field Type", "program");
					UIComponent.modifySetting(fieldMap2, "program", "ENODCLDocumentUI");
					UIComponent.modifySetting(fieldMap2, "function", "getTitleOfRefernceDocument");



					HashMap fieldMap3 = new HashMap<>();
					fieldMap3.put("expression_businessobject", "empty");
					fieldMap3.put(UICache.LABEL, strRefDocLable);
					fieldMap3.put(UICache.NAME, "RefDoc" + "$" + strId);
					UIComponent.modifySetting(fieldMap3, "Editable", "true");
					UIComponent.modifySetting(fieldMap3, "Input Type", "combobox");
					UIComponent.modifySetting(fieldMap3, "Range Program", "ENODCLDocumentUI");
					UIComponent.modifySetting(fieldMap3, "Range Function", "getReferenceDocumentCategoryRanges");

					HashMap fieldMap4 = new HashMap<>();
					fieldMap4.put(UICache.LABEL, "   ");
					fieldMap4.put(UICache.NAME, "RefDocEmpty" + "$" + strId);
					UIComponent.modifySetting(fieldMap4, "Editable", "false");
					UIComponent.modifySetting(fieldMap4, "Field Type", "Section Header");

					customerAttFields.add(fieldMap);
					customerAttFields.add(fieldMap1);
					customerAttFields.add(fieldMap2);
					customerAttFields.add(fieldMap3);
					customerAttFields.add(fieldMap4);

				}
			}
			return customerAttFields;
		}
		catch (Exception e) {
			throw new Exception(e.getLocalizedMessage());
		}
	}


	public  boolean  ifReferenceDocumentCategorizationEnabled(Context context, String[] args) throws DCLException{
		try{
			Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
			String strControlledDocument = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_TYPE_CONTROLLED_DOCUMENTS);
			String strParentOID=(String) programMap.get("parentOID");
			boolean isRefDocCategoryEnabled=false;
			boolean isControlledDocuemnt=false;
			if(!DCLUtil.isNullOrEmpty(strParentOID)){
				isControlledDocuemnt=(DomainObject.newInstance(context,strParentOID)).isKindOf(context, strControlledDocument);
			}
			if(isControlledDocuemnt){
				try	
				{
					isRefDocCategoryEnabled =DCUtil.ifReferenceDocumentCategorizationEnabled(context);
				}catch(FrameworkException e){
					isRefDocCategoryEnabled = false;
				}
			}
			return isRefDocCategoryEnabled;
		}catch(Exception e1){
			throw new DCLException(e1.getLocalizedMessage());
		}
	}


	public String getTypeOfRefernceDocument(Context context, String[] args)
			throws DCLException {
		String strType="";
		try {
			Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
			Map fieldMap = (Map) programMap.get("fieldMap");
			Map settingsMap = (Map) fieldMap.get("settings");
			String fieldName=(String)fieldMap.get("name");
			String strId=(String)(FrameworkUtil.split(fieldName,"$")).get(1);
			strType=DomainObject.newInstance(context,strId).getInfo(context,"type");
		}catch(Exception e){
		}
		return strType;
	}

	public String getNameOfRefernceDocument(Context context, String[] args)
			throws DCLException {
		String strName="";
		try {
			Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
			Map fieldMap = (Map) programMap.get("fieldMap");
			Map settingsMap = (Map) fieldMap.get("settings");
			String fieldName=(String)fieldMap.get("name");
			String strId=(String)(FrameworkUtil.split(fieldName,"$")).get(1);
			strName=DomainObject.newInstance(context,strId).getInfo(context,"name");
		}catch(Exception e){
		}
		return strName;
	}

	public String getTitleOfRefernceDocument(Context context, String[] args)
			throws DCLException {
		String strTitle="";
		try {
			Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
			Map fieldMap = (Map) programMap.get("fieldMap");
			Map settingsMap = (Map) fieldMap.get("settings");
			String fieldName=(String)fieldMap.get("name");
			String strId=(String)(FrameworkUtil.split(fieldName,"$")).get(1);
			strTitle=DomainObject.newInstance(context,strId).getInfo(context,"attribute["+PropertyUtil.getSchemaProperty(context, DomainSymbolicConstants.SYMBOLIC_attribute_Title)+"]");
		}catch(Exception e){
		}
		return strTitle;
	}	

	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map preProcessCheckin(Context context, String[] args)
			throws Exception
	{
		Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
		String[] saObjectId = (String[]) programMap.get(DCLConstants.OBJECTID);
		String showFileTitle="true";
		String showFileCategory="true";
		ControlledDocumentService documentService = DCLServiceUtil.getControlledDocumentService(context);

		String fileCategoryList=  documentService.getCategories(context,saObjectId[0]);
		Map mReturnMap=new HashMap();
		mReturnMap.put(DCLConstants.ACTION_JAVASCRIPT, "preProcessCheckin('"+saObjectId[0]+"',"+showFileTitle+","+showFileCategory+",'"+fileCategoryList+"');");
		return mReturnMap;
	}





	public boolean hasDocumentAddFilesAccessAndFileCategorizationEnable(Context context,String args[]) throws Exception
	{

		boolean canCheckin = JPO.invoke(context, "emxCommonDocument", null, "hasDocumentAddFilesAccess", args, Boolean.class);
		String isFileCategoryEnable="false"; 
		try {
			isFileCategoryEnable=EnoviaResourceBundle.getProperty(context, "enoDocumentControl.Files.EnableFileCategories");
		}
		catch(Exception e)
		{

		}
		if(canCheckin && Boolean.valueOf(isFileCategoryEnable))
			return true;
		return false;
	}
	public boolean hasDocumentAddFilesAccess(Context context,String args[]) throws Exception
	{

		boolean canCheckin = JPO.invoke(context, "emxCommonDocument", null, "hasDocumentAddFilesAccess", args, Boolean.class);
		String isFileCategoryEnable="false"; 
		try {
			isFileCategoryEnable=EnoviaResourceBundle.getProperty(context, "enoDocumentControl.Files.EnableFileCategories");
		}
		catch(Exception e)
		{

		}
		if(canCheckin && !Boolean.valueOf(isFileCategoryEnable))
			return true;
		return false;
	}


	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String, String> actionMoveUp(Context context, String[] args) throws Exception {
		Map<String,String> mReturn = new HashMap<String,String>();
		try {

			Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
			String[] saObjectId=(String[])programMap.get("objectId");
			String[] sTableRowIds = (String[]) programMap.get("emxTableRowId");
			int len=sTableRowIds.length;
			List<TableRowId> rowIds = TableRowId.getTableRowIds(sTableRowIds);
			ControlledDocumentService service = DCLServiceUtil.getControlledDocumentService(context);

			String strErrorMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.CannotSequence", new String[] {}, null,
					context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
			for (String strRowIds : sTableRowIds) {
				String strRowId = strRowIds;
				TableRowId tr = new TableRowId(strRowId);
				String strFileId = tr.getObjectId();
				if (service.isUnControlledPDFCopyToBeDeleted(context, DomainObject.newInstance(context,strFileId))) {
					mReturn.put(DCLConstants.ACTION_JAVASCRIPT,DCLUtil.encodeFunctionForJavaScript(context, false, "alertMessage", strErrorMessage));
					return mReturn;
				}
			}
			String framename = "DCLDocumentFiles";

			for (int i = 0; i < rowIds.size(); i++) {

				service.moveUp(context,  rowIds.get(i).getObjectId(),
						saObjectId[0]);
			}
			mReturn.put(DCLConstants.ACTION_JAVASCRIPT,DCLUtil.encodeFunctionForJavaScript(context, false, "refreshFileStructureView", FrameworkUtil.join(sTableRowIds, "::"),
					framename));
		}
		catch (Exception e) {
			String strErrorMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.CannotSequenceOutOfparent", new String[] {}, null,
					context.getLocale(), DCLConstants.DCL_STRING_RESOURCE);
			mReturn.put( DCLConstants.ACTION_JAVASCRIPT,DCLUtil.encodeFunctionForJavaScript(context, false, "alertMessage", strErrorMessage));
		}
		return mReturn;
	}

	@com.dassault_systemes.enovia.documentcommon.ExecuteCallable
	public Map<String, String>  actionMoveDown(Context context, String[] args) throws Exception {
		Map<String,String> mReturn = new HashMap<String,String>();
		try {
			Map<?, ?> programMap = (Map<?, ?>) JPO.unpackArgs(args);
			String[] saObjectId=(String[])programMap.get("objectId");
			String[] sTableRowIds = (String[]) programMap.get("emxTableRowId");
			List<TableRowId> rowIds = TableRowId.getTableRowIds(sTableRowIds);
			ControlledPrintingService controlledPrintservice = new ControlledPrintingServiceImpl();
			ControlledDocumentService service = DCLServiceUtil.getControlledDocumentService(context);
			String strErrorMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.CannotSequence",
					new String[] {}, null, context.getLocale(),
					DCLConstants.DCL_STRING_RESOURCE);
			for(String strRowIds:sTableRowIds) {
				String strRowId=strRowIds;
				TableRowId tr=new TableRowId(strRowId);
				String strFileId=tr.getObjectId();
				if(service.isUnControlledPDFCopyToBeDeleted(context, DomainObject.newInstance(context, strFileId))) 
				{				
					mReturn.put( DCLConstants.ACTION_JAVASCRIPT,DCLUtil.encodeFunctionForJavaScript(context, false, "alertMessage", strErrorMessage));
					return mReturn;
				}
			}	
			String framename = "DCLDocumentFiles";

			for (int i = rowIds.size() - 1; i >= 0; i--) {

				service.moveDown(
						context,
						rowIds.get(i).getObjectId(),
						saObjectId[0]);
			}
			mReturn.put( DCLConstants.ACTION_JAVASCRIPT,DCLUtil.encodeFunctionForJavaScript(context, false, "refreshFileStructureView", FrameworkUtil.join(sTableRowIds, "::"),
					framename));
		}
		catch (Exception e) {
			String strErrorMessage = MessageUtil.getMessage(context, null, "enoDocumentControl.Alert.CannotSequenceOutOfparent",
					new String[] {}, null, context.getLocale(),
					DCLConstants.DCL_STRING_RESOURCE);
			mReturn.put( DCLConstants.ACTION_JAVASCRIPT,DCLUtil.encodeFunctionForJavaScript(context, false, "alertMessage", strErrorMessage));
		}
		return mReturn;
	}

	public  boolean  isFileCategoriesEnabled(Context context, String[] args) throws DCLException{
		try{
			ControlledDocumentService service = DCLServiceUtil.getControlledDocumentService(context);
			return service.isFileCategoriesEnabled(context);
		}catch(Exception e1){
			throw new DCLException(e1.getLocalizedMessage());
		}
	}
	public Vector<String> getColumnFileCategory(Context context, String[] args) 
			throws DCLException 
			{
		try 
		{
			Map programMap = (Map) JPO.unpackArgs(args);
			MapList mlObjectList = (MapList) programMap.get(DCConstants.OBJECTLIST);
			Map paramList = (Map) programMap.get(DCConstants.PARAMLIST);
			String strReportFormat = (String) paramList.get(DCConstants.REPORTFORMAT);
			Vector<String> categoryList = new Vector<String>();
			// Getting the bus ids for objects in the table
			List<String> slObjectid=new StringList();

			String strInterface = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_INTERFACE_SYSTEM_GENERATED_PRINT);
			String attrFileCategory = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_FILE_CATEGORY);

			for (Object object : mlObjectList) 
			{
				Map map = (Map) object;
				String strId = (String) map.get(DomainConstants.SELECT_ID);
				if(UIUtil.isNotNullAndNotEmpty(strId))
				{
					DomainObject domObj = DomainObject.newInstance(context, strId);
					StringList fileInterface = domObj.getInfoList(context, "interface");
					if(fileInterface.contains(strInterface))
							{
							domObj.getPreviousRevision(context);
							BusinessObject busFile=domObj.getPreviousRevision(context);
							if(busFile.exists(context))
							{
								domObj=DomainObject.newInstance(context, busFile.getObjectId(context));
								 String fileCategory=domObj.getInfo(context, DomainObject.getAttributeSelect(attrFileCategory));
									categoryList.add(fileCategory);
							}
							else
						categoryList.add( EnoviaResourceBundle.getProperty(context, DCLConstants.DCL_STRING_RESOURCE, context.getLocale(),
								"enoDocumentControl.Range.Rendition"));
								
							
							}
							
					else {
						String fileCategory=domObj.getInfo(context, DomainObject.getAttributeSelect(attrFileCategory));
						categoryList.add(fileCategory);
					}
			}
			}			return categoryList;
		} catch (Exception ex) {
			throw new DCLException(ex.getMessage());
		}
			}

	public void updateFileCategoryColumn (Context context,String[] args) throws Exception
	{
		Map mpAttributes = new HashMap();
		String attrFileCategory = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_FILE_CATEGORY);
		Map hmProgram = (Map) JPO.unpackArgs(args);
		Map hmParam = (Map) hmProgram.get(DCLConstants.PARAMMAP);
		String strDocId = (String) hmParam.get(DCConstants.OBJECTID);
		String strNewValue = (String) hmParam.get(DCLConstants.NEW_VALUE);
		DomainObject.newInstance(context,strDocId).setAttributeValue(context, attrFileCategory, strNewValue);
	}
	public StringList checkEditAccessFileCategoryColumn(Context context,String[] args)throws Exception {
		try {
			String strInterface = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_INTERFACE_SYSTEM_GENERATED_PRINT);
			List<String> list = new StringList();
			Map<?,?> paramMap = (Map<?,?>)JPO.unpackArgs(args);
			List<Map> mobjectList = (List<Map>)paramMap.get(DCConstants.OBJECTLIST);
			String strPolicyVersion=PropertyUtil.getSchemaProperty(context,DomainSymbolicConstants.SYMBOLIC_policy_Version);
			boolean isEditActionReqd = false;
			for(Map mObjectMap:mobjectList)
			{
				isEditActionReqd = true;
				String strObjectId=(String)mObjectMap.get(DomainConstants.SELECT_ID);
				if(!UIUtil.isNullOrEmpty(strObjectId)) {
					DomainObject dobj = DomainObject.newInstance(context,strObjectId);		
					String policy=dobj.getInfo(context, DomainObject.SELECT_POLICY);
					StringList fileInterface = dobj.getInfoList(context, "interface");
					if(fileInterface.contains(strInterface) || !policy.equals(strPolicyVersion))
						isEditActionReqd = false;

				}
				list.add(String.valueOf(isEditActionReqd));
			}
			return (StringList)list;
		} catch (FrameworkException e) {
			throw new Exception(e);
		} catch (Exception e) {
			throw new Exception(e);
		}

	}

	public  boolean  showEditOnReferenceDocumentTable(Context context, String[] args) throws DCLException{
		try{
			return 	DCUtil.ifReferenceDocumentCategorizationEnabled(context);

		}catch(Exception e1){
			throw new DCLException(e1.getLocalizedMessage());
		}
	}
	
	public Map getFileCategoryRanges(Context context, String[] args)
			throws DCLException {
		try {
			StringList slChoice = new StringList(2);
			StringList slDisplay = new StringList();
			List<String> slCategory=DCUtil.getCategoryRangeValues(context,"enoDocumentControl.FileCategory.RangeValues");
			for(String strCategory:slCategory){
				slChoice.add(strCategory);
				String strDisplayValue=strCategory;
				try{
					strDisplayValue=EnoviaResourceBundle.getProperty(context, "enoDocumentControlStringResource", context.getLocale(),
							"enoDocumentControl.Range.File_Category." + strCategory.replace(" ", "_"));
				}catch(Exception e1){
					strDisplayValue=strCategory;
				}
				slDisplay.add(strDisplayValue);
			}
			Map rangeMap = new HashMap();
			rangeMap.put(DCLConstants.FIELD_CHOICES, slChoice);
			rangeMap.put(DCLConstants.FIELD_DISPLAY_CHOICES, slDisplay);
			return rangeMap;
		} catch (Exception e) {
			throw new DCLException(e.getLocalizedMessage());
		}   
	}
public Vector<String> getColumnFileSequence(Context context, String[] args) 
			throws DCLException 
  {
	  try 
	  {
		  Map programMap = (Map) JPO.unpackArgs(args);
		  MapList mlObjectList = (MapList) programMap.get(DCConstants.OBJECTLIST);
		  Map paramList = (Map) programMap.get(DCConstants.PARAMLIST);
		  String strReportFormat = (String) paramList.get(DCConstants.REPORTFORMAT);
		  Vector<String> sequenceList = new Vector<String>();
		  // Getting the bus ids for objects in the table
		  List<String> slObjectid=new StringList();

		  String strInterface = PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_INTERFACE_SYSTEM_GENERATED_PRINT);
		  String attrFileSequence= PropertyUtil.getSchemaProperty(context, DCLConstants.SYMBOLIC_ATTRIBUTE_FILE_SEQUENCE);

		  for (Object object : mlObjectList) 
		  {
			  Map map = (Map) object;
			  String strId = (String) map.get(DomainConstants.SELECT_ID);
			  if(UIUtil.isNotNullAndNotEmpty(strId))
			  {
				  DomainObject domObj = DomainObject.newInstance(context, strId);
				  StringList fileInterface = domObj.getInfoList(context, "interface");
				  if(fileInterface.contains(strInterface))
				  {
					  domObj.getPreviousRevision(context);
					  BusinessObject busFile=domObj.getPreviousRevision(context);
					  if(busFile.exists(context))
					  {
						  domObj=DomainObject.newInstance(context, busFile.getObjectId(context));
						  String fileSequence=domObj.getInfo(context, DomainObject.getAttributeSelect(attrFileSequence));
						  sequenceList.add(fileSequence);
					  }
					  else
						  sequenceList.add("");

				  }

				  else {
					  String fileSequence=domObj.getInfo(context, DomainObject.getAttributeSelect(attrFileSequence));
					  sequenceList.add(fileSequence);
				  }
			  }
		  }
		  return sequenceList;
	  } catch (Exception ex) {
		  throw new DCLException(ex.getMessage());
	  }
  }
 public  boolean  isConsolidationEnabled(Context context, String[] args) throws DCLException{
		try{
			return ControlledPrintingUtil.isRenditionModeConsolidated(context);
			}catch(Exception e1){
			throw new DCLException(e1.getLocalizedMessage());
		}
	}


}


